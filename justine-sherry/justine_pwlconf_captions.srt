1
00:00:05,500 --> 00:00:10,870
my name is Justine and I work on building
network systems, but this talk applies to,

2
00:00:10,870 --> 00:00:11,870
ooh, this is pretty echoey.

3
00:00:11,870 --> 00:00:15,670
I'm going to move this down a little bit.

4
00:00:15,670 --> 00:00:21,240
I think this talk applies to pretty much anybody
who builds software, and in this talk I'm

5
00:00:21,240 --> 00:00:24,539
super-open to questions and conversation.

6
00:00:24,539 --> 00:00:29,090
In fact, in graduate networking classes these
papers are sort of notorious for leading to

7
00:00:29,090 --> 00:00:33,220
arguments and discussion which is part of
why these are two papers that I really, really

8
00:00:33,220 --> 00:00:35,430
love.

9
00:00:35,430 --> 00:00:43,079
>> OK, so we've all had the experience of
working with our piece of code and we start

10
00:00:43,079 --> 00:00:47,750
talking about the features that we want and
at some point we start thinking about how

11
00:00:47,750 --> 00:00:51,039
other people or services are going to use
our widget.

12
00:00:51,039 --> 00:00:55,850
And we usually do this by implementing APIs
to talk to these other services.

13
00:00:55,850 --> 00:01:03,020
This is actually a very short narrow view
of our piece of software in the world.

14
00:01:03,020 --> 00:01:06,640
In reality it's a small part of this big ecosystem.

15
00:01:06,640 --> 00:01:11,090
There are other service that is our widgets
talk to directly, maybe some extensions up

16
00:01:11,090 --> 00:01:12,920
and down the stack.

17
00:01:12,920 --> 00:01:17,740
Maybe you're running on one of multiple different
platforms that you support and maybe many,

18
00:01:17,740 --> 00:01:21,000
many layers away there's some human user.

19
00:01:21,000 --> 00:01:22,350
[laughter]

20
00:01:22,350 --> 00:01:26,670
So today we're going to talk about design
philosophy and we're going to talk about principles

21
00:01:26,670 --> 00:01:32,300
for thinking about the world outside of your
widget, even and especially if your widget

22
00:01:32,300 --> 00:01:38,950
is kind of abstract, far down the stack, and
invisible from the average human.

23
00:01:38,950 --> 00:01:40,829
This is David Clark.

24
00:01:40,829 --> 00:01:43,530
And many people in the networking community
sort of worship him.

25
00:01:43,530 --> 00:01:48,670
He's a research scientists at MIT and well
deserving title, Internet Philosopher.

26
00:01:48,670 --> 00:01:53,620
Most of the seminal work on this topic is
due to things that he was involved with.

27
00:01:53,620 --> 00:01:59,149
And to I recommended three papers for the
Papers We Love community to read and upon

28
00:01:59,149 --> 00:02:02,329
realizing that I only have one hour to speak
I actually cut one.

29
00:02:02,329 --> 00:02:11,640
So these are the papers we're going to talk
about.

30
00:02:11,640 --> 00:02:13,390
All three involve Clark as a coauthor.

31
00:02:13,390 --> 00:02:20,730
As a side note, I met David Clark at a conference
once, he told me he liked my talk.

32
00:02:20,730 --> 00:02:23,460
It was great.

33
00:02:23,460 --> 00:02:28,760
[laughter]
Anyway, before we dig in the papers, I'm going

34
00:02:28,760 --> 00:02:33,800
to give some background and what systems folks
mean when they talk about laird architectures,

35
00:02:33,800 --> 00:02:37,470
because we're going to talk a lot about layers,
and we're going to focus especially on the

36
00:02:37,470 --> 00:02:41,620
internet because that's what I and David Clark
work on an for those of you who internet all

37
00:02:41,620 --> 00:02:47,790
day, just hang with me as I go through some
material we're familiar with it.

38
00:02:47,790 --> 00:02:50,640
So we talked about modular.

39
00:02:50,640 --> 00:02:52,730
And they fit together in layers.

40
00:02:52,730 --> 00:02:57,300
One of these is the internet model we have
here.

41
00:02:57,300 --> 00:03:03,580
At the bottom we have our physical layer,
this is the thing that turns electricity and

42
00:03:03,580 --> 00:03:06,000
wire into bits.

43
00:03:06,000 --> 00:03:14,140
The link layer is all about turning bits on
a wire into messages, you've probably heard

44
00:03:14,140 --> 00:03:15,409
about ethernet.

45
00:03:15,409 --> 00:03:19,840
When machines are talking to each other an
a wire, they're using ethernet.

46
00:03:19,840 --> 00:03:23,909
The network layer is the internet protocol.

47
00:03:23,909 --> 00:03:31,480
It's the thing that gives us the addresses
that allow us to talk across great distances.

48
00:03:31,480 --> 00:03:36,319
And the transport layer is the thing that's
concerned with connections between hosts.

49
00:03:36,319 --> 00:03:41,050
Often the transport layer is responsible for
resending data that has been lost or making

50
00:03:41,050 --> 00:03:43,910
sure it doesn't get corrupted or reordered.

51
00:03:43,910 --> 00:03:49,440
And at the very top we have the part that
your average Joe actually see, the tip of

52
00:03:49,440 --> 00:03:53,379
the iceberg speaking.

53
00:03:53,379 --> 00:03:58,300
Web browsers, email, chat clients, etc.

54
00:03:58,300 --> 00:04:04,330
The way these pieces fit together I'll show
through a demonstration, so here I have me

55
00:04:04,330 --> 00:04:10,400
and Zeeshan, and I'm going to send him this
sweet paper in a PDF file.

56
00:04:10,400 --> 00:04:12,750
At the application layer, I load up my PDF.

57
00:04:12,750 --> 00:04:17,120
My application is going to send this down
to the transport layer, which establishes

58
00:04:17,120 --> 00:04:20,260
a connection and converts it into packets.

59
00:04:20,260 --> 00:04:25,060
These packets, it's going to assign some sequence
numbers, it's using these sequence numbers

60
00:04:25,060 --> 00:04:28,110
to make sure that things don't get lost or
reordered.

61
00:04:28,110 --> 00:04:32,970
These packets get handed down to the network
layer where we put an IP address on them,

62
00:04:32,970 --> 00:04:37,880
that is how we know where to send the data
and then down at the link layer we hand these

63
00:04:37,880 --> 00:04:46,610
packetized into the physical layer which takes
in the bits and ships them across some wires.

64
00:04:46,610 --> 00:04:51,550
At the other side the physical layer hands
this back up to the link layer, reconstructs

65
00:04:51,550 --> 00:04:57,080
our packets, hands them back up to the network
layer, now we know, OK, this is really me,

66
00:04:57,080 --> 00:04:59,780
these are the packets sent to me.

67
00:04:59,780 --> 00:05:05,180
The transport layer we double-check, is everything
in order, have I lost any pieces and then

68
00:05:05,180 --> 00:05:08,870
we glue everything back together and hand
it back up to the application layer where

69
00:05:08,870 --> 00:05:11,750
we can reconstruct or PDF.

70
00:05:11,750 --> 00:05:12,750
Sweet.

71
00:05:12,750 --> 00:05:18,340
So the internet is just one example of a modular
layered system.

72
00:05:18,340 --> 00:05:23,120
Components are implemented independently with
layers between them.

73
00:05:23,120 --> 00:05:26,610
Different layers may have multiple implementations.

74
00:05:26,610 --> 00:05:33,410
For example, you have wifi versus wired internet
as your physical layer, and different layers

75
00:05:33,410 --> 00:05:37,419
may offer slightly different APIs and different
functionality.

76
00:05:37,419 --> 00:05:43,360
For example, TCP and UDP are both transport
protocols, but TCP guarantees that nothing

77
00:05:43,360 --> 00:05:46,259
will get lost and everything shows up in order.

78
00:05:46,259 --> 00:05:53,360
UDP doesn't give you any such guarantees,
and to make your end to end system work, data

79
00:05:53,360 --> 00:05:57,710
has to pass through multiple layers, we're
plugging all these components together to

80
00:05:57,710 --> 00:06:00,310
make our big internet.

81
00:06:00,310 --> 00:06:04,960
Now, networks aren't the only systems with
layers.

82
00:06:04,960 --> 00:06:09,110
People in the storage systems draw diagrams
that look pretty familiar to me.

83
00:06:09,110 --> 00:06:17,639
You have your application, your and then things
get written out to your disk or your solid

84
00:06:17,639 --> 00:06:19,970
state drive.

85
00:06:19,970 --> 00:06:26,880
Virtualization, also another context where
we run into layers, your hardware has a kernel

86
00:06:26,880 --> 00:06:32,479
on top of it, your kernel is running a hypervisor
on type of it, that hypervisor has some guest

87
00:06:32,479 --> 00:06:36,500
kernels and those guest kernels have user
space on top of them again.

88
00:06:36,500 --> 00:06:41,360
So there's layers all around us.

89
00:06:41,360 --> 00:06:46,580
So today's questions when we're talking about
design philosophy is how to not get myopic

90
00:06:46,580 --> 00:06:49,460
about living in our own little layer.

91
00:06:49,460 --> 00:06:55,530
We need to think about the outside world and
not just about the APIs that we expose to

92
00:06:55,530 --> 00:06:58,289
the components we're talking to directly.

93
00:06:58,289 --> 00:07:05,940
We need to look all the way up and down the
stack, and even up to the users on top.

94
00:07:05,940 --> 00:07:14,330
So, further ado, got some background now and
we can talk about paper No. 1.

95
00:07:14,330 --> 00:07:20,320
Papers called end to end arguments and systems
design, it appeared in November, 1984, three

96
00:07:20,320 --> 00:07:21,870
years before I was born.

97
00:07:21,870 --> 00:07:26,870
Appeared in ACM transactions on computer systems
which was kind of a big deal and it's one

98
00:07:26,870 --> 00:07:31,690
of the very influential papers that people
tend to read in all sorts of graduate systems

99
00:07:31,690 --> 00:07:34,690
class, network systems, databases, etc.

100
00:07:34,690 --> 00:07:40,220
And the paper starts out with an example that
you should now be familiar with, now that

101
00:07:40,220 --> 00:07:45,880
I've shown you how the internet works, and
it involves an oversimplified layer system.

102
00:07:45,880 --> 00:07:47,120
We only have three components.

103
00:07:47,120 --> 00:07:52,870
We have a file system, a program, and a network,
and notice that we've now sign p seen diagrams

104
00:07:52,870 --> 00:07:57,039
of file systems and networks and we know that
each of these components has lots of layers

105
00:07:57,039 --> 00:07:58,039
inside of it.

106
00:07:58,039 --> 00:08:01,319
We've collapsed all of that down into this
one block.

107
00:08:01,319 --> 00:08:04,470
So in this example we're looking at a careful
file transfer.

108
00:08:04,470 --> 00:08:15,010
Program A calls upon the file system and the
file system passes it to the file transfer

109
00:08:15,010 --> 00:08:22,319
program in fixed-size blocks, these fixed-size
blocks are happened down to the communication

110
00:08:22,319 --> 00:08:23,319
program.

111
00:08:23,319 --> 00:08:29,020
The communication system is going to transmit
the tile using some communication protocol

112
00:08:29,020 --> 00:08:38,030
that involves splitting the data into packets.

113
00:08:38,030 --> 00:08:44,380
The data communication network moves the packets
from computer A to computer B, and it at host

114
00:08:44,380 --> 00:08:49,080
B, the communication program removes the packets
from the communication channel and hands the

115
00:08:49,080 --> 00:08:56,470
contained data up to the file transfer application,
the part that operates within B. At host B,

116
00:08:56,470 --> 00:09:01,870
the file transfer program asks the file program
to write the data to disk.

117
00:09:01,870 --> 00:09:03,790
Done.

118
00:09:03,790 --> 00:09:05,720
Problem.

119
00:09:05,720 --> 00:09:09,580
What if Zeeshan later reads the file and finds
that it's corrupted?

120
00:09:09,580 --> 00:09:11,050
What could have gone wrong?

121
00:09:11,050 --> 00:09:14,020
Well, it turns out a lot of things can go
wrong.

122
00:09:14,020 --> 00:09:18,459
The paper lists a long list of reasons.

123
00:09:18,459 --> 00:09:23,350
You could have problems in the disk storage
system, bit error, whatever.

124
00:09:23,350 --> 00:09:27,140
Storage, you could have problems in the file
system, the file transfer program, some buffer

125
00:09:27,140 --> 00:09:30,830
overrun in the data communications system,
some error in copying.

126
00:09:30,830 --> 00:09:35,990
You could have some bug in the processer,
a bit flip in memory.

127
00:09:35,990 --> 00:09:41,910
The communications system might drop packets,
have corruption, deliver a packet more than

128
00:09:41,910 --> 00:09:42,910
once.

129
00:09:42,910 --> 00:09:44,660
This is actually a thing that the internet
does sometimes.

130
00:09:44,660 --> 00:09:49,260
Either of the host might just crash while
you're in the middle of it.

131
00:09:49,260 --> 00:09:55,720
The question is, how do we redesign our system
to make sure the file doesn't get corrupted

132
00:09:55,720 --> 00:09:59,370
and to start we need to know where do we make
these changes?

133
00:09:59,370 --> 00:10:00,950
Do the we change it up to the file system?

134
00:10:00,950 --> 00:10:03,970
Do we do them in the program?

135
00:10:03,970 --> 00:10:06,889
Do we do them in the network?

136
00:10:06,889 --> 00:10:11,230
This is what the end to end argument is meant
to help us with and I've added in some red

137
00:10:11,230 --> 00:10:13,940
text that I think makes it more readable.

138
00:10:13,940 --> 00:10:20,940
The end to end argument goes like this: If
the function in question can completely and

139
00:10:20,940 --> 00:10:25,730
correctly be implemented with the knowledge
and the help of the application standing at

140
00:10:25,730 --> 00:10:32,440
the endpoints of the communication system,
then, providing that question function as

141
00:10:32,440 --> 00:10:38,410
a feature of the communication system or lower
layer, is not possible.

142
00:10:38,410 --> 00:10:43,761
However, sometimes an incomplete version of
the function provided by the communication

143
00:10:43,761 --> 00:10:46,480
system may be useful as a performance enhancement.

144
00:10:46,480 --> 00:10:47,881
So let's look at the first part.

145
00:10:47,881 --> 00:10:50,980
The if, then, and forget about the however
for a while.

146
00:10:50,980 --> 00:10:57,360
If you could implement your function at the
end, at the top layer, do it there.

147
00:10:57,360 --> 00:10:59,640
Don't do it somewhere down low.

148
00:10:59,640 --> 00:11:01,110
Here's why.

149
00:11:01,110 --> 00:11:05,120
Let's say that I went ahead and just made
a perfectly reliable communication network.

150
00:11:05,120 --> 00:11:10,330
I had introduced some sort of network coding
or acknowledgment at the network layer to

151
00:11:10,330 --> 00:11:13,400
make sure nothing ever got dropped or corrupted
on the wire.

152
00:11:13,400 --> 00:11:21,149
Well, if we go back to our long list of things
that can go wrong, I'm just circling the components

153
00:11:21,149 --> 00:11:25,450
that can have problems, not the actual problems
that happen.

154
00:11:25,450 --> 00:11:32,200
Fixing our errors at this low layer here actually
only fix things for the communications system.

155
00:11:32,200 --> 00:11:35,680
It doesn't fix anything going wrong in your
processer, it doesn't fix anything going wrong

156
00:11:35,680 --> 00:11:38,250
in your disk, it doesn't fix bugs in your
code.

157
00:11:38,250 --> 00:11:43,360
So it just wasn't very helpful.

158
00:11:43,360 --> 00:11:47,920
The paper then proposes an alternative better
solution which they call end to end check

159
00:11:47,920 --> 00:11:49,620
and retry.

160
00:11:49,620 --> 00:11:52,399
Here's the idea.

161
00:11:52,399 --> 00:11:56,870
Our sender is going to read the file in its
check sum from disk and then it's going to

162
00:11:56,870 --> 00:12:00,120
verify the file in the check sum and make
sure they add up.

163
00:12:00,120 --> 00:12:04,800
Then we send both the file and the check sum.

164
00:12:04,800 --> 00:12:09,710
Everything proceeds exactly the same as B
packets down, they get sent across the network

165
00:12:09,710 --> 00:12:18,639
and at the other end when Zeeshan receives
the file he's going to write the file to disk

166
00:12:18,639 --> 00:12:24,649
along with its check sum and then read it
back and verify that the two match up.

167
00:12:24,649 --> 00:12:29,209
If they match up, we know we're done, end
to end, the whole thing is complete and we

168
00:12:29,209 --> 00:12:30,209
got the right file.

169
00:12:30,209 --> 00:12:34,600
And if they don't match up, Zeeshan will go
back and ask me, can you just resend the file,

170
00:12:34,600 --> 00:12:38,390
something went wrong.

171
00:12:38,390 --> 00:12:43,029
Note that checking at the end all the way
past the finish line we'll be able to catch

172
00:12:43,029 --> 00:12:52,820
if anything went wrong anywhere along the
line.

173
00:12:52,820 --> 00:12:56,019
So we actually would have to do this check
no matter what.

174
00:12:56,019 --> 00:13:07,500
And if we're doing it here, why bother doing
it at a lower layer?

175
00:13:07,500 --> 00:13:09,149
>> It's usually redundant.

176
00:13:09,149 --> 00:13:19,381
And second of all, they argue that it can
often cause confusion and they give an example

177
00:13:19,381 --> 00:13:23,470
of a communications system at MI where they
kept seeing corrupted files.

178
00:13:23,470 --> 00:13:28,300
Turns out there was a memory error, but everybody
just assumed, well, our communication system

179
00:13:28,300 --> 00:13:34,080
is reliable, so we don't have to check anything
at higher layers.

180
00:13:34,080 --> 00:13:39,200
The paper then goes on to suggest other places
that the end to end protocol can be useful.encryption

181
00:13:39,200 --> 00:13:45,570
is a really great example here.

182
00:13:45,570 --> 00:13:52,490
You still need end to end encryption, because
just because your VPN offers encryption, it

183
00:13:52,490 --> 00:13:57,120
doesn't mean that the person at the other
end can't see your data.

184
00:13:57,120 --> 00:14:01,320
You need ACS at the higher layer.

185
00:14:01,320 --> 00:14:07,110
You will you see this played out in the earlier
days of the internet.

186
00:14:07,110 --> 00:14:15,570
People said the internet needs to be real
reliable.

187
00:14:15,570 --> 00:14:18,540
Today's internet doesn't do any of those things.

188
00:14:18,540 --> 00:14:23,850
Transport protocols at the endpoints of communication,
double-check if something got lost or corrupted

189
00:14:23,850 --> 00:14:27,210
and resend if it got missing.

190
00:14:27,210 --> 00:14:34,550
So, there's one caveat to this implement everything
at the endpoints argument.

191
00:14:34,550 --> 00:14:38,779
Sometimes as a performance optimization you
really do want to implement things at the

192
00:14:38,779 --> 00:14:43,370
lower layer of the system, rather than -- at
same time as you're implementing at the higher

193
00:14:43,370 --> 00:14:49,920
layer and that's only when you really, really
need that optimization.

194
00:14:49,920 --> 00:14:54,899
Consider if all of our loss was really happening
at the network layer, and that loss rate was

195
00:14:54,899 --> 00:15:00,240
really high, the higher the loss rate in the
network, the less likely it is that our whole

196
00:15:00,240 --> 00:15:04,000
PDF, end to end, is actually going to make
it all the way through.

197
00:15:04,000 --> 00:15:09,160
If we have these five packets and each one
has a 28% chance of loss, that's a really

198
00:15:09,160 --> 00:15:13,920
high chance, 65% that the file wouldn't make
it all the way through.

199
00:15:13,920 --> 00:15:23,130
So as a performance optimization, we might
want to bake in some reliability at the network

200
00:15:23,130 --> 00:15:28,390
layer, but we should do that redundantly,
and without forgetting that we have to do

201
00:15:28,390 --> 00:15:30,230
it end to end, as well.

202
00:15:30,230 --> 00:15:34,089
Anybody have any other thoughts on where this
kind of thing plays out?

203
00:15:34,089 --> 00:15:38,630
Where you can do a redundant performance optimization
in your system?

204
00:15:38,630 --> 00:15:39,630
No?

205
00:15:39,630 --> 00:15:43,560
Wifi is a great example.

206
00:15:43,560 --> 00:15:49,650
Wifi redundantly does retransmission.

207
00:15:49,650 --> 00:15:52,990
That's because wifi can get really lossy when
somebody turns a microwave on.

208
00:15:52,990 --> 00:15:57,800
OK, so far this has been pretty dry.

209
00:15:57,800 --> 00:16:01,630
What the heck is this classic networking argument
that grad students argue about.

210
00:16:01,630 --> 00:16:03,540
There's nothing really to argue about here.

211
00:16:03,540 --> 00:16:09,850
Well, that's because the paper, in like the
very last section, turns the argument a little

212
00:16:09,850 --> 00:16:11,209
bit and tweaks it.

213
00:16:11,209 --> 00:16:13,640
And they make a stronger argument.

214
00:16:13,640 --> 00:16:20,380
They say, and in many cases while it's not
just a waste of time to build things at low

215
00:16:20,380 --> 00:16:26,650
layers and it's not just confusing, it's actually
really harmful to the internet.

216
00:16:26,650 --> 00:16:29,960
Whoa, OK.

217
00:16:29,960 --> 00:16:33,850
Here's how that plays out.

218
00:16:33,850 --> 00:16:41,370
Well, one way to add reliability is to add
some extra bits, like network coding.

219
00:16:41,370 --> 00:16:45,720
But that also means that you have slightly
less bandwidth coming through your network

220
00:16:45,720 --> 00:16:47,640
layer, you've taken up some extra bits.

221
00:16:47,640 --> 00:16:55,269
Another way to do that is to use acknowledgments,
and to withhold packets until you've got all

222
00:16:55,269 --> 00:16:56,269
the data.

223
00:16:56,269 --> 00:16:59,480
If something goes missing, you wait for a
retransmit, and once you've got everything,

224
00:16:59,480 --> 00:17:03,670
you pass it up to the application layer, which
adds more latency.

225
00:17:03,670 --> 00:17:07,990
So this is really not helpful for an application
like Skype.

226
00:17:07,990 --> 00:17:10,850
With Skype, I really don't want my packets
showing up late.

227
00:17:10,850 --> 00:17:13,959
As a matter of fact, I don't care if all of
them show up.

228
00:17:13,959 --> 00:17:20,360
I don't care, because I'd much rather have
a small blip than receiving everything 30

229
00:17:20,360 --> 00:17:24,280
seconds late but knowing that I got all of
it.

230
00:17:24,280 --> 00:17:30,400
So this shows how some applications can actually
be constrained by extra functionality that

231
00:17:30,400 --> 00:17:31,400
they don't want.

232
00:17:31,400 --> 00:17:36,730
In our Skype case it's that having better
latency and bandwidth is more important than

233
00:17:36,730 --> 00:17:38,980
getting all the data.

234
00:17:38,980 --> 00:17:43,340
So what's good in one context isn't good for
everything.

235
00:17:43,340 --> 00:17:49,720
This paper that came out in 1984 was oddly
prescient because in the internet today this

236
00:17:49,720 --> 00:17:53,690
problem is a huge deal.

237
00:17:53,690 --> 00:17:57,590
Here's one example that's super-common in
network enterprises networks today.

238
00:17:57,590 --> 00:18:09,120
Everyone is expected to run antivirus to protect
them from bad guys on the internet.

239
00:18:09,120 --> 00:18:12,300
We've used the endpoints to protect us from
badness.

240
00:18:12,300 --> 00:18:19,220
But some people don't always keep their computers
updated and as an optimization, many network

241
00:18:19,220 --> 00:18:25,669
administrators want to filter traffic based
on what they suspect is malicious and nonmalicious,

242
00:18:25,669 --> 00:18:28,160
to protect these users.

243
00:18:28,160 --> 00:18:32,150
And they do this by observing what traffic
usually leads to attacks and what usually

244
00:18:32,150 --> 00:18:35,750
doesn't and they tend to be pretty conservative
about this.

245
00:18:35,750 --> 00:18:39,220
Web traffic and email, it's usually OK.

246
00:18:39,220 --> 00:18:45,130
Start seeing IRC, that stuff is dangerous,
strange port numbers, not so good.

247
00:18:45,130 --> 00:18:50,280
So it's really common to put some box in your
network that enforces this.

248
00:18:50,280 --> 00:18:55,970
Only allow web traffic and email and maybe
that's historically all you've seen your users

249
00:18:55,970 --> 00:18:57,250
use.

250
00:18:57,250 --> 00:19:06,930
But then somebody has some cool new app that
runs over some high-number port number.

251
00:19:06,930 --> 00:19:12,380
It's perfectly safe but it isn't HTTP or email
and now it can't get through our network because

252
00:19:12,380 --> 00:19:20,830
we've baked in a security optimization into
the low layers of the system.

253
00:19:20,830 --> 00:19:25,211
So here's a paper that came out just a couple
of years ago, and it proposes that we should

254
00:19:25,211 --> 00:19:30,780
now use HTTP for everything, they say that
when you have your new app nowadays, firewalls

255
00:19:30,780 --> 00:19:36,890
block pretty much everything except HTTP so
you either go around to every network administrator

256
00:19:36,890 --> 00:19:43,150
in the world or you can just build arbitrary
programs.

257
00:19:43,150 --> 00:19:49,900
So this whole paper is how to build random
programs that look like HTTP web traffic that

258
00:19:49,900 --> 00:19:56,169
aren't web traffic at all, so despite the
good and useful security benefits of our firewalls

259
00:19:56,169 --> 00:20:02,419
and our IDSs, they've constrained what applications
are or aren't allowed in networks, in a way

260
00:20:02,419 --> 00:20:06,200
that's not great.

261
00:20:06,200 --> 00:20:08,740
Here's another example, from the real world.

262
00:20:08,740 --> 00:20:14,580
Your iPhone usually connects to web services
over LTE or 3G and this is what we imagine

263
00:20:14,580 --> 00:20:20,720
it looks like, but in practice, many ISPs
insert consent caches to make things load

264
00:20:20,720 --> 00:20:25,760
faster for you, so they're keeping copies
of frequently fetched data and instead of

265
00:20:25,760 --> 00:20:34,510
you collecting all the weight of their web
server, you're connecting to their cache.

266
00:20:34,510 --> 00:20:46,360
I but this problem arose when some folks in
the UK started designing a new transport protocol.

267
00:20:46,360 --> 00:20:51,600
They called it multipath TCP and the idea
here was to send some of your traffic over

268
00:20:51,600 --> 00:20:59,170
your LTE connection and some traffic over
wifi, so you get better bandwidth.

269
00:20:59,170 --> 00:21:03,410
And then these caches looked at it and said,
this looks like a TCP connection, but half

270
00:21:03,410 --> 00:21:04,510
the packets are missing.

271
00:21:04,510 --> 00:21:05,590
What do I do with this?

272
00:21:05,590 --> 00:21:11,059
Now, they could have just said, OK I'll let
it route through, I won't perform any optimizations,

273
00:21:11,059 --> 00:21:13,350
but instead they just blocked it and the whole
thing broke.

274
00:21:13,350 --> 00:21:19,799
So this this paper the multipath TCP authors
talked about challenges they faced when they

275
00:21:19,799 --> 00:21:25,220
tried to use this multipath protocol on the
public internet.

276
00:21:25,220 --> 00:21:30,020
It just turns out that all of these optimizations
that normally had made things faster were

277
00:21:30,020 --> 00:21:32,690
causing problems for their new protocol.

278
00:21:32,690 --> 00:21:37,560
Luckily this story does have a very happy
ending, the authors developed some work-and.

279
00:21:37,560 --> 00:21:41,950
And multipath TVP now works in your iPhone
so that's great.

280
00:21:41,950 --> 00:21:48,670
And this is where grad students start to go
off the rails, the internet is hopeless.

281
00:21:48,670 --> 00:21:56,150
I think most of us have some sort of story
where we were being blocked or filtered, we

282
00:21:56,150 --> 00:21:59,030
had a hotel that wouldn't let us use SSH.

283
00:21:59,030 --> 00:22:03,800
What's going on?

284
00:22:03,800 --> 00:22:11,140
So I'm just going to recap the arguments I've
heard from the end to end argument.

285
00:22:11,140 --> 00:22:17,140
The basic argument, the thing that's not so
controversial.

286
00:22:17,140 --> 00:22:22,590
In you could implement functionality completely
at endpoints, do it there.

287
00:22:22,590 --> 00:22:24,370
Don't do it at a lower layer.

288
00:22:24,370 --> 00:22:30,710
It saves on redundant work and it can avoid
confusion, but you might, and sometimes you

289
00:22:30,710 --> 00:22:34,200
really want to, make exceptions for performance
optimizations.

290
00:22:34,200 --> 00:22:40,289
Then there's the strong argument, you should
really avoid putting unneeded functionality

291
00:22:40,289 --> 00:22:42,559
in lower layers of your system altogether.

292
00:22:42,559 --> 00:22:48,880
It's harmful and as many have foretold it's
going to doom innovation on the internet forever.

293
00:22:48,880 --> 00:22:54,890
Extra functionality at lower layers constrains
how applications are designed at higher layers

294
00:22:54,890 --> 00:22:56,809
so we should just avoid it.

295
00:22:56,809 --> 00:23:00,020
OK, that's the end to end argument.

296
00:23:00,020 --> 00:23:01,660
Any questions up to here?

297
00:23:01,660 --> 00:23:02,730
Yes.

298
00:23:02,730 --> 00:23:12,310
Do they talk at all about opt out functionality?

299
00:23:12,310 --> 00:23:14,179
>> So they'll talk a little bit about that.

300
00:23:14,179 --> 00:23:18,419
So the question is, do they talk about opt-out
functionality, making sure that if you add

301
00:23:18,419 --> 00:23:20,370
extra functionality, can you optimize it.

302
00:23:20,370 --> 00:23:26,120
In this next paper we'll get a little bit
into that.

303
00:23:26,120 --> 00:23:28,290
>>
[inaudible]

304
00:23:28,290 --> 00:23:38,000
Verification -- if you implemented verification
at the file system there, wouldn't that have

305
00:23:38,000 --> 00:23:44,059
the same problem of constraining -- according
to the Strong argument of constraining behavior,

306
00:23:44,059 --> 00:23:47,980
if you were check summing at the file system.

307
00:23:47,980 --> 00:23:53,831
>> It's true that I might have some application,
so the question here is this end to end communication

308
00:23:53,831 --> 00:23:57,520
argument really assumes that the network is
at the bottom and that the file system is

309
00:23:57,520 --> 00:24:02,360
somehow high lea and we should be checking
things in the file system.

310
00:24:02,360 --> 00:24:05,650
But it's true that in other people's diagrams
of the world the file system is down here

311
00:24:05,650 --> 00:24:10,460
at the bottom and maybe I have some app that's
reading lots and lots of data really fast

312
00:24:10,460 --> 00:24:20,929
and it doesn't have time to do verification
check sums.

313
00:24:20,929 --> 00:24:26,660
These questions are super tricky.

314
00:24:26,660 --> 00:24:27,660
That's a great point.

315
00:24:27,660 --> 00:24:32,120
I'd never thought of that one.

316
00:24:32,120 --> 00:24:33,120
OK.

317
00:24:33,120 --> 00:24:38,600
>> So we've given some good arguments for
why you shouldn't bake things into lower layers

318
00:24:38,600 --> 00:24:43,060
and then we've said that for some optimizations
you probably really going to want to sometimes

319
00:24:43,060 --> 00:24:45,970
bake things into lower layers, but it could
be harmful.

320
00:24:45,970 --> 00:24:47,880
It might not be harmful.

321
00:24:47,880 --> 00:24:49,720
Sometimes it's helpful.

322
00:24:49,720 --> 00:24:59,009
So who decides what optimizations and constraints
are OK to employ at core layers of our systems.

323
00:24:59,009 --> 00:25:07,970
>> 20 years David Clark comes out with his
internet philosopher crown -- that crown is

324
00:25:07,970 --> 00:25:14,200
not real but I would like to give him -- and
he says the internet is not a single happy

325
00:25:14,200 --> 00:25:19,610
family of people dedicated to universal packet
carriage.

326
00:25:19,610 --> 00:25:21,940
What?

327
00:25:21,940 --> 00:25:27,000
And here are some examples he gives us of
our very unhappy family.

328
00:25:27,000 --> 00:25:31,559
People want to talk in private over the network
and the government wants to build in some

329
00:25:31,559 --> 00:25:36,980
wiretaps at the bottom layers of our system.

330
00:25:36,980 --> 00:25:41,159
Conservative governments put their users behind
firewalls.

331
00:25:41,159 --> 00:25:47,340
Users not only don't like this, but they actually
just route around it, they install VPNs.

332
00:25:47,340 --> 00:25:53,789
ISPs tell us you can have one host on this
network connection, and we are enforcing this

333
00:25:53,789 --> 00:25:59,010
by giving you one IP address and everyone's
house has a network address translator with

334
00:25:59,010 --> 00:26:03,550
lots of laptops behind it.

335
00:26:03,550 --> 00:26:07,840
So in the tussle paper, the authors call these
arguments tussles.

336
00:26:07,840 --> 00:26:15,570
It's the ongoing contention between parties
with conflicting interests surrounding a mechanism.

337
00:26:15,570 --> 00:26:21,650
Different parties adapt a mix of mechanisms
to achieve conflicting goals and others respond

338
00:26:21,650 --> 00:26:25,490
by adapting the mechanisms to push back.

339
00:26:25,490 --> 00:26:30,029
We need to emphasize the term mechanism here,
because this is a really interesting conflict

340
00:26:30,029 --> 00:26:34,950
in that the mechanism is both the object of
the argument and it's something that pushes

341
00:26:34,950 --> 00:26:40,240
back on people and makes them change their
behavior.

342
00:26:40,240 --> 00:26:42,010
>> Here's a recent example.

343
00:26:42,010 --> 00:26:47,340
Back in 2014, there was some controversy about
iCloud.

344
00:26:47,340 --> 00:26:51,380
Apple had this great iCloud data storage system
that allowed you to back up your data to the

345
00:26:51,380 --> 00:26:52,380
cloud.

346
00:26:52,380 --> 00:26:53,380
It was pretty cool.

347
00:26:53,380 --> 00:26:55,980
But the government wanted to access that data.

348
00:26:55,980 --> 00:27:02,600
They wanted to subpoena information that people
were storing in iCloud.

349
00:27:02,600 --> 00:27:08,650
We had two users, we had all of us who wanted
to use it for storage and we had our government

350
00:27:08,650 --> 00:27:14,039
who thought great, we can use this for legal
investigations, but Apple questioned whether

351
00:27:14,039 --> 00:27:18,480
or not the government's use of their customers'
information was in the public interest.

352
00:27:18,480 --> 00:27:26,990
So they expanded their encryption feature
with the release of iOS 8.

353
00:27:26,990 --> 00:27:38,760
So even Apple itself wouldn't be able to unlock
it.

354
00:27:38,760 --> 00:27:46,210
The government 
didn't like this.

355
00:27:46,210 --> 00:27:52,350
They tried to get Apple to change it again
by developing a new back door to get them

356
00:27:52,350 --> 00:27:56,860
to access the data during the San Bernardino.

357
00:27:56,860 --> 00:27:59,080
This tussle is still going on.

358
00:27:59,080 --> 00:28:00,290
It didn't end.

359
00:28:00,290 --> 00:28:03,679
The government got somebody else to build
the back door.

360
00:28:03,679 --> 00:28:10,990
But this will not be the last we'll hear about
this mechanism companies are or aren't allowed

361
00:28:10,990 --> 00:28:16,620
to implement and what restrictions they can
bake into those to stop the government from

362
00:28:16,620 --> 00:28:20,789
acting on it.

363
00:28:20,789 --> 00:28:26,700
So to describe these arguments, the tussles
talk about an actor model for tussle.

364
00:28:26,700 --> 00:28:31,900
Basically everybody has their own goals and
desires that everyone is constrained by the

365
00:28:31,900 --> 00:28:36,980
system that they're using, and they're trying
to use the system to compete -- to achieve

366
00:28:36,980 --> 00:28:39,240
their own competing desires.

367
00:28:39,240 --> 00:28:43,850
So here we have a designer, Claire, whose
design is constraining her users, Dahlia and

368
00:28:43,850 --> 00:28:52,080
Zeeshan, so Claire designs, the system imposes
some constraints on them, and Zeeshan and

369
00:28:52,080 --> 00:28:57,880
Dahlia are adapting, building work-and, so
they're asking for a back door to be built,

370
00:28:57,880 --> 00:29:03,580
they are a designing a VPN to get around it,
maybe they're moving to another service.

371
00:29:03,580 --> 00:29:14,480
So in response to these work-arounds and adaptations,
we go through this process over and over again.

372
00:29:14,480 --> 00:29:21,090
Now, note that these redesigns can sometimes
extend restrictions or they can actually help

373
00:29:21,090 --> 00:29:22,090
the work-around.

374
00:29:22,090 --> 00:29:26,880
I like to think of when people, you remember
when we used to write RT in the retweets and

375
00:29:26,880 --> 00:29:29,399
then copy-paste somebody's retweet?

376
00:29:29,399 --> 00:29:34,909
This was because there was a lack of ability
to.

377
00:29:34,909 --> 00:29:38,020
Twitter noticed this work-around and thought
that's a great work around.

378
00:29:38,020 --> 00:29:44,169
That's awesome and now they have this nice
little retweet button.

379
00:29:44,169 --> 00:29:55,160
And there's an open question about this process.

380
00:29:55,160 --> 00:29:58,940
Whether the tussle is going to be driven out
of the system, actors are all going to be

381
00:29:58,940 --> 00:30:03,049
forced to align, everybody is going to agree,
hold hands, go home, or whether this sort

382
00:30:03,049 --> 00:30:07,910
of semi-stable dynamic where we just keep
adapting and changing and adapting and changing,

383
00:30:07,910 --> 00:30:12,720
is going to persist forever.

384
00:30:12,720 --> 00:30:14,260
So back to design philosophy.

385
00:30:14,260 --> 00:30:17,110
We're sitting here thinking about our wig
ets, we're now aware of tussle.

386
00:30:17,110 --> 00:30:20,700
We're 11 layers down the stack, no one has
ever heard of with what we're building.

387
00:30:20,700 --> 00:30:24,400
And we need to think about how do we impact
the world around us?

388
00:30:24,400 --> 00:30:28,980
How do we design for tussle?

389
00:30:28,980 --> 00:30:31,330
There's two ways to think about designing
for tussle.

390
00:30:31,330 --> 00:30:38,700
One is to think about staying out of the tussle,
just let people's fights play out agnostically,

391
00:30:38,700 --> 00:30:42,010
you stay out of the fight, your system is
it pure.

392
00:30:42,010 --> 00:30:44,450
Another way is to design to influence the
tussle.

393
00:30:44,450 --> 00:30:45,450
Take a stand.

394
00:30:45,450 --> 00:30:50,600
Now, the paper is a little schizophrenic on
this issue.

395
00:30:50,600 --> 00:30:55,299
It starts out talking about how you should
design to stay out of the tussle, build these

396
00:30:55,299 --> 00:31:00,940
beautiful agnostic systems and then it pivots
towards the end and it talks about designing

397
00:31:00,940 --> 00:31:02,710
to influence the tussle.

398
00:31:02,710 --> 00:31:07,519
So let's first talk about the design principles
that they talk about to stay out of the tussle

399
00:31:07,519 --> 00:31:09,990
and where they start to pivot after that.

400
00:31:09,990 --> 00:31:13,950
So first they say, design for variation outcome.

401
00:31:13,950 --> 00:31:16,460
Do not design as if to dictate the outcome.

402
00:31:16,460 --> 00:31:18,549
Stay out of the way.

403
00:31:18,549 --> 00:31:23,700
And they propose two rules, two design principles
for us to follow.

404
00:31:23,700 --> 00:31:26,390
Modularity, and designing for choice.

405
00:31:26,390 --> 00:31:28,700
I'll talk about each of these.

406
00:31:28,700 --> 00:31:29,909
First modular design.

407
00:31:29,909 --> 00:31:36,600
Now, my description of modular design is to
make somebody else' decision, not yours and

408
00:31:36,600 --> 00:31:38,019
they give two examples.

409
00:31:38,019 --> 00:31:41,070
One of bad modularity and one of good modularity.

410
00:31:41,070 --> 00:31:50,450
Bad modularity is DNS.

411
00:31:50,450 --> 00:31:52,360
The DNS is the name of the service.

412
00:31:52,360 --> 00:31:53,420
That's it.

413
00:31:53,420 --> 00:31:57,260
For the world at large, the DNS is a trademark,
it's someone's name.

414
00:31:57,260 --> 00:32:03,510
So this international technical organization,
who managed service IDs is now embroiled in

415
00:32:03,510 --> 00:32:06,279
trademark disputes in every country in the
world.

416
00:32:06,279 --> 00:32:16,880
Here's poor

417
00:32:16,880 --> 00:32:32,510
Carly Fiorna, who forgot to buy her own domain
name.

418
00:32:32,510 --> 00:32:37,159
We've conflated the idea of service ID and
trademark, we shouldn't have been in this

419
00:32:37,159 --> 00:32:41,049
game in the first place.

420
00:32:41,049 --> 00:32:43,370
Here's good modularity.

421
00:32:43,370 --> 00:32:44,380
Internet quality of service many.

422
00:32:44,380 --> 00:32:48,730
The way it works is pretty simple, here we
have our IP header and we've put in a couple

423
00:32:48,730 --> 00:32:51,529
of bits.

424
00:32:51,529 --> 00:32:59,790
The higher the number, the less important
we assume you are.

425
00:32:59,790 --> 00:33:04,720
So alternatively, we could have removed these
bits all together, to save on bandwidth we're

426
00:33:04,720 --> 00:33:06,640
using lets bits and that's it great.

427
00:33:06,640 --> 00:33:13,840
And then we would bake into the system, all
right, failed calls are the most important

428
00:33:13,840 --> 00:33:17,440
and video games are the least important.

429
00:33:17,440 --> 00:33:22,649
But then we have baked into the system a choice
about what is or isn't important and that's

430
00:33:22,649 --> 00:33:24,640
not really our job.

431
00:33:24,640 --> 00:33:30,130
Instead, the people who instead QOS said it
should be up to the community or the enterprise

432
00:33:30,130 --> 00:33:32,580
in that region.

433
00:33:32,580 --> 00:33:36,580
Those communities can decide for themselves
what they do or don't think is important and

434
00:33:36,580 --> 00:33:44,680
they'll just tell us, they'll give us an ordered
ranking so this is good modularity here.

435
00:33:44,680 --> 00:33:50,519
Now, the other principle they present is designing
for choice.

436
00:33:50,519 --> 00:33:51,850
Letting the user decide.

437
00:33:51,850 --> 00:33:54,429
How many guys are from the EU?

438
00:33:54,429 --> 00:33:55,429
Anybody?

439
00:33:55,429 --> 00:33:56,429
Yeah, OK.

440
00:33:56,429 --> 00:33:58,130
You recognize this screen?

441
00:33:58,130 --> 00:34:03,510
So when you install windows in the US, you
get Internet Explorer, that's it, that's the

442
00:34:03,510 --> 00:34:09,260
only option and the EU said this is anticompetitive,
this is not fair, you have not designed for

443
00:34:09,260 --> 00:34:10,260
choice.

444
00:34:10,260 --> 00:34:15,310
In the EU when you installed Windows, you
get a screen that lets you choose what web

445
00:34:15,310 --> 00:34:17,050
browser do you want?

446
00:34:17,050 --> 00:34:20,450
And then you just choose whichever.

447
00:34:20,450 --> 00:34:23,840
And they install that one for you.

448
00:34:23,840 --> 00:34:26,919
Designing for choice I think is a little bit
easier to reason about than modularity.

449
00:34:26,919 --> 00:34:38,060
We're sort of used to thinking about modularity.

450
00:34:38,060 --> 00:34:41,940
We all have different email providers, we
can run different operating systems, regardless

451
00:34:41,940 --> 00:34:44,810
of the hardware that we run.

452
00:34:44,810 --> 00:34:50,210
Sometimes it's not quite clear, what's the
difference between designing modularly and

453
00:34:50,210 --> 00:34:51,460
designing for choice.

454
00:34:51,460 --> 00:34:56,530
And I think the big difference is really the
context in which you apply them in.

455
00:34:56,530 --> 00:35:02,820
Until modular design you're concerned about
a global decision that has to be made for

456
00:35:02,820 --> 00:35:04,010
everyone.

457
00:35:04,010 --> 00:35:06,550
For example, those QLS bits.

458
00:35:06,550 --> 00:35:10,470
I know plenty of people who would say that
I think that my video game traffic is way

459
00:35:10,470 --> 00:35:12,960
more important than 911 calls.

460
00:35:12,960 --> 00:35:16,600
I do not want to let them design for choice.

461
00:35:16,600 --> 00:35:25,230
There has to be a global decision made somewhere
but our architecture that we've designed,

462
00:35:25,230 --> 00:35:27,180
shouldn't assume what that choice is.

463
00:35:27,180 --> 00:35:30,930
You should outsource it to something that
represents the decision of the community or

464
00:35:30,930 --> 00:35:34,280
the company or the place where it's being
deployed.

465
00:35:34,280 --> 00:35:39,410
Designing for choice is what you do when the
decision doesn't need to be global.

466
00:35:39,410 --> 00:35:44,500
Where it's really totally fine that to each
his own, everybody does things differently.

467
00:35:44,500 --> 00:35:52,680
So the paper goes on to discuss another -- a
number of other places where tussles come

468
00:35:52,680 --> 00:35:53,680
into play.

469
00:35:53,680 --> 00:35:59,720
Here are some examples: Some ISPs ban users
from hosting web servers and so they block

470
00:35:59,720 --> 00:36:00,720
port 80.

471
00:36:00,720 --> 00:36:01,810
User solution?

472
00:36:01,810 --> 00:36:06,470
Obviously just run your web server hon a different
port.

473
00:36:06,470 --> 00:36:10,990
Residential broadband access is another place
where they were oddly prescient, here they

474
00:36:10,990 --> 00:36:16,180
are back in 2005, saying today we have about
6,000 dialup providers in the US and people

475
00:36:16,180 --> 00:36:27,020
have lots of choice about their provider but
we're worried about broadband and today.

476
00:36:27,020 --> 00:36:32,450
The internet today has not designed for choice
when I get to choose between which providers

477
00:36:32,450 --> 00:36:36,760
I have.

478
00:36:36,760 --> 00:36:40,599
Trust is another place where tussles play
out.

479
00:36:40,599 --> 00:36:43,579
People want to talk to me, but I doesn't want
them to communicate with me.

480
00:36:43,579 --> 00:36:46,549
I set up firewalls, I set up filters, I set
up antivirus.

481
00:36:46,549 --> 00:36:51,520
The internet is open by default, but how should
this mechanism in the middle decide who to

482
00:36:51,520 --> 00:36:52,520
listen to?

483
00:36:52,520 --> 00:36:56,460
Me who says don't talk to me or the person
who's sending me all the spam.

484
00:36:56,460 --> 00:37:06,480
Anybody think of any other systems designed
by choice any time you're done your own work?

485
00:37:06,480 --> 00:37:07,480
Electrical grid.

486
00:37:07,480 --> 00:37:08,630
>> Electrical grid.

487
00:37:08,630 --> 00:37:10,599
Tell me more.

488
00:37:10,599 --> 00:37:20,450
>> We're starting to see where you can choose
your electricity provider, but the grid is

489
00:37:20,450 --> 00:37:21,450
a utility.

490
00:37:21,450 --> 00:37:22,450
>> That's fantastic, I didn't know about that
example.

491
00:37:22,450 --> 00:37:23,540
That's great.

492
00:37:23,540 --> 00:37:26,750
>> Similar to the internet.

493
00:37:26,750 --> 00:37:28,650
>> Did everybody hear that?

494
00:37:28,650 --> 00:37:30,079
The electrical grid?

495
00:37:30,079 --> 00:37:32,460
Yeah, that's on the captions.

496
00:37:32,460 --> 00:37:33,460
Cool.

497
00:37:33,460 --> 00:37:34,460
>> OK.

498
00:37:34,460 --> 00:37:39,860
So facing all these challenges, the tussle
paper gives us some pretty stern commands.

499
00:37:39,860 --> 00:37:44,270
After saying you should stay out of the fight,
you should design for choice, you should make

500
00:37:44,270 --> 00:37:50,440
it somebody else's decision, they then say
there's no such thing as value-neutral designs,

501
00:37:50,440 --> 00:37:51,810
don't assume that you know the answer.

502
00:37:51,810 --> 00:37:56,849
You weren't designing a playing field but
at the same time you can't be value-neutral.

503
00:37:56,849 --> 00:37:58,900
So here's the editors' bias.

504
00:37:58,900 --> 00:38:05,810
Their bias is that openness, choice, and tussle
are good and they're reacting to a lot of

505
00:38:05,810 --> 00:38:10,339
pressures to end choice in the way that we
build our infrastructure.

506
00:38:10,339 --> 00:38:18,849
There are app stores that restrict what apps
you can and can't install on your iPhone or

507
00:38:18,849 --> 00:38:20,360
Android or Kindle.

508
00:38:20,360 --> 00:38:26,349
There are protocols to standardization efforts
that have been undermined by governments that

509
00:38:26,349 --> 00:38:28,480
want to restrict strong cryptography.

510
00:38:28,480 --> 00:38:38,230
There are firewalls, IDSs, and filters that
both protect us from badness and implement

511
00:38:38,230 --> 00:38:44,901
censoring, filter out competition and downgrade
undesirable traffic and typically these are

512
00:38:44,901 --> 00:38:51,190
corporations and governments who want to control
what's going on.

513
00:38:51,190 --> 00:38:57,869
So when the authors of this paper say to design
to stay out of tussle, they also are simultaneously

514
00:38:57,869 --> 00:39:03,589
telling us influence the tussle in that everyone
gets a say.

515
00:39:03,589 --> 00:39:08,220
Don't bake in features that you're pushed
to do by the government or a corporation or

516
00:39:08,220 --> 00:39:10,490
some user who you really like.

517
00:39:10,490 --> 00:39:13,440
Let it play out in the world, in the community.

518
00:39:13,440 --> 00:39:20,460
They then return to the end to end argument
and they say, look, sometimes you're going

519
00:39:20,460 --> 00:39:24,420
to have to make some decision, you're going
to have to bake some optimizations or features

520
00:39:24,420 --> 00:39:28,370
down into that network layer that are going
to strain the rest of the world.

521
00:39:28,370 --> 00:39:34,420
Evolution and enhancement of existing, mature
applications is inevitable but you should

522
00:39:34,420 --> 00:39:40,070
always be worried about new applications and
new use cases and keeping the net open and

523
00:39:40,070 --> 00:39:44,460
transparent for new applications should be
the most important goal.

524
00:39:44,460 --> 00:39:51,190
>> And the most that we can do is to protect
maturing application is to bias the tussle.

525
00:39:51,190 --> 00:39:56,070
To bias the tussle in terms of continuing
to play out, rather than stagnating and coming

526
00:39:56,070 --> 00:40:01,630
up with some locked-down design that only
does one thing that one person has allowed.

527
00:40:01,630 --> 00:40:05,130
Yeah, David Clark.

528
00:40:05,130 --> 00:40:09,500
[laughter]
So back to you and your widget.

529
00:40:09,500 --> 00:40:14,650
I hope that you're now armed with some design
principles, you can look at end-to-end system

530
00:40:14,650 --> 00:40:20,069
design to implement complex functionality
at high layers of your system and keep those

531
00:40:20,069 --> 00:40:28,430
core layers open and flexible.

532
00:40:28,430 --> 00:40:36,930
Let multiple options be available to your
users and design modularly, so that your system

533
00:40:36,930 --> 00:40:42,810
is agnostic to which decision is made and
different communities can make their own choices

534
00:40:42,810 --> 00:40:47,670
about what is or isn't appropriate to bake
into the lower layers of the system.

535
00:40:47,670 --> 00:40:53,020
Now, fur if you're interested in reading more
on this, first of all there's the paper that

536
00:40:53,020 --> 00:40:54,020
I downgraded.

537
00:40:54,020 --> 00:41:01,099
The design philosophy of the DARPA internet
protocols.

538
00:41:01,099 --> 00:41:10,060
Among other things, it's really interesting
to just look at what motivated them at the

539
00:41:10,060 --> 00:41:11,060
time.

540
00:41:11,060 --> 00:41:14,870
They were super-worried about nuclear bombs
destroying the internet and not worried about

541
00:41:14,870 --> 00:41:17,230
privacy or cryptography at all.

542
00:41:17,230 --> 00:41:18,230
Very strange.

543
00:41:18,230 --> 00:41:24,491
There are also the other two papers I talked
about that reflect on how the network, the

544
00:41:24,491 --> 00:41:27,350
internet today, is constraining application
development.

545
00:41:27,350 --> 00:41:32,700
This is HTTP action the narrow waist of the
internet and is it still possible to extend

546
00:41:32,700 --> 00:41:34,780
TCP paper.

547
00:41:34,780 --> 00:41:40,540
And finally a very controversial paper which
I think is very cool is a paper that says

548
00:41:40,540 --> 00:41:45,609
that the evolution of laird protocol stacks
leads to an hour-glass-shaped architecture.

549
00:41:45,609 --> 00:41:52,660
There are a lot of protocols that we use at
the physical layer, there are a lot of application

550
00:41:52,660 --> 00:41:55,410
that is we run but there's only one internet
protocol.

551
00:41:55,410 --> 00:41:57,470
Why don't we have many?

552
00:41:57,470 --> 00:42:00,930
This paper tries to answer that question.

553
00:42:00,930 --> 00:42:07,261
So at the end of the day, going back to your
super-widget, remember: Are you giving your

554
00:42:07,261 --> 00:42:11,640
users choice or are you adding constraints?

555
00:42:11,640 --> 00:42:19,710
Thanks very much.

556
00:42:19,710 --> 00:42:35,819
[applause]
>> Hello, thanks for the talk.

557
00:42:35,829 --> 00:42:41,079
In the paper, they kind of criticize DNS and
say that it's bad for trademarks or something.

558
00:42:41,079 --> 00:42:42,079
>> Yes.

559
00:42:42,079 --> 00:42:46,589
>> What sort of concretely positively, like,
are they suggesting?

560
00:42:46,589 --> 00:42:48,369
>> So they don't suggest an alternative.

561
00:42:48,369 --> 00:42:50,160
Which I found really annoying reading the
paper.

562
00:42:50,160 --> 00:42:53,740
I actually spent some time trying to imagine.

563
00:42:53,740 --> 00:43:00,770
You could have some sort of opaque service
ID and then yet another layer of indirection,

564
00:43:00,770 --> 00:43:06,310
where you could subscribe to Google's naming
trademarking service and that would be relevant

565
00:43:06,310 --> 00:43:10,230
to the US and in China they would have their
own trademarking service that would map to

566
00:43:10,230 --> 00:43:22,069
those service IDs, it seems a little hokey
to me, actually, everything I could think

567
00:43:22,069 --> 00:43:25,579
of to separate those too, was a little eh,
iffy.

568
00:43:25,579 --> 00:43:30,570
>> Thank you for this excellent talk.

569
00:43:30,570 --> 00:43:37,530
The -- I certainly see the value and the philosophy
behind pushing things up to the end, but how

570
00:43:37,530 --> 00:43:43,980
do you address, for something like say TCP/IP,
the sharing network that we hope will launch

571
00:43:43,980 --> 00:43:52,069
this year, if there's something that you know
every application is going to need to do these

572
00:43:52,069 --> 00:43:57,290
things, even if you say we could solve this,
but we still have to worry about corrupted

573
00:43:57,290 --> 00:44:06,310
hard drives, so we're still going to have
to do the end-to-end check but in turns of

574
00:44:06,310 --> 00:44:16,859
trying to get a thousand applications getting
everything right?

575
00:44:16,859 --> 00:44:22,240
>> Well, so what operating systems do today
on this front is actually very nice.

576
00:44:22,240 --> 00:44:23,650
Your OS knows about it.

577
00:44:23,650 --> 00:44:32,690
CP, knows about UDP and your application is
not reimplementing TCP every time.

578
00:44:32,690 --> 00:44:37,369
The communication layer at the bottom isn't
making the decision for you, so they've designed

579
00:44:37,369 --> 00:44:39,430
for choice in that way.

580
00:44:39,430 --> 00:44:43,750
They've pushed it to the end points but they've
pushed it in such a way that applications

581
00:44:43,750 --> 00:44:46,299
can plug and play which component they want.

582
00:44:46,299 --> 00:44:47,600
>> Not all the way up.

583
00:44:47,600 --> 00:44:48,980
>> Yeah, so not all the way up.

584
00:44:48,980 --> 00:44:50,109
Into software.

585
00:44:51,500 --> 00:45:04,320
>>
ZEESHAN:    Any other questions?

586
00:45:04,960 --> 00:45:06,500
>> Great, thanks.

