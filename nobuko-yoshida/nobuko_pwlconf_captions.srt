1
00:00:05,490 --> 00:00:14,230
So first I want to introduce you to our website, on the main website on here if you want to

2
00:00:14,230 --> 00:00:25,090
read or test our theory based on the session types, and the order of information, more or less, will appear

3
00:00:25,090 --> 00:00:31,580
here and we have a home, and there are either some news under -- our work was announced

4
00:00:31,580 --> 00:00:37,150
by active developer in the conference on Scala.

5
00:00:37,150 --> 00:00:43,220
Some of the session work that is applied to
that Scala language, and we

6
00:00:43,220 --> 00:00:46,600
have application to Go where we talked about

7
00:00:46,600 --> 00:00:53,880
our work at the Golang UK conference with developers, and like this, we have some information listed

8
00:00:53,880 --> 00:00:54,760
here.

9
00:00:54,900 --> 00:01:05,239
And then we have the home and then all publications are listed here, and so I will select some

10
00:01:05,239 --> 00:01:12,979
of them to talk with you -- to talk today,
and about the other things that we have here.

11
00:01:12,979 --> 00:01:20,239
And, also, tools, we have several applications with the session types to Go, and Scala, and

12
00:01:20,240 --> 00:01:33,160
Haskell, and for example, you have C++, and the main project is with Redhat, Cognizant,

13
00:01:33,160 --> 00:01:35,360
and OOI with Scribble projects,

14
00:01:35,360 --> 00:01:39,300
of which I will talk about, and
actors in

15
00:01:39,300 --> 00:01:43,000
the Python C, and the Java and so on

16
00:01:43,000 --> 00:01:50,740
there, and those are the tools under public
source code available from git which you can get.

17
00:01:50,740 --> 00:01:59,159
And I want to inform you about one thing,
and Kohei Honda was my collaborator and he

18
00:01:59,159 --> 00:02:05,399
originated in session types and his information is also available here, but I

19
00:02:05,399 --> 00:02:15,160
want to start now about the talk from here.

20
00:02:15,160 --> 00:02:20,170
So what is a session type and session types is the

21
00:02:20,170 --> 00:02:29,690
types, you know types, for example, Boolean, Integer, and Character, and also bit, which is difficult array

22
00:02:29,690 --> 00:02:30,500
types

23
00:02:30,500 --> 00:02:38,000
and in Haskell, you have functional types,
session types is a types likes functional

24
00:02:38,000 --> 00:02:41,180
types for concurrency and method parsing.

25
00:02:41,180 --> 00:02:51,140
Today, I introduce you about session types
and so that everybody here can understand

26
00:02:51,140 --> 00:02:53,520
session types definitely

27
00:02:54,060 --> 00:02:57,260
definitely yes. I promise you.

28
00:02:57,260 --> 00:02:58,620
[laughter]

29
00:02:58,880 --> 00:03:01,120
And so here you go.

30
00:03:01,120 --> 00:03:04,160
And here is the current members of our group.

31
00:03:04,160 --> 00:03:15,360
I have three female Ph.D. students, who's
female students coming next year: And also another postdoc

32
00:03:15,360 --> 00:03:16,400
and this

33
00:03:16,400 --> 00:03:25,540
is a selected list of our publications, I
don't know why it's not displayed properly

34
00:03:25,540 --> 00:03:32,420
[fixing display]

35
00:03:32,460 --> 00:03:34,500
OK, this way it's better.

36
00:03:34,500 --> 00:03:41,080
And so I'm not talking on everything today,
and this is two years of our publications,

37
00:03:41,080 --> 00:03:47,960
but, so I cut out my publications and there
are

38
00:03:47,960 --> 00:03:56,880
three categories I can find: These types are
a very theoretical work of the session types

39
00:03:56,880 --> 00:04:02,940
and session types is the type theory of concurrency, so these papers

40
00:04:02,940 --> 00:04:09,400
are very difficult, probably, for you to read and very complicated.

41
00:04:09,400 --> 00:04:17,120
However, green letters is about applications of session types to the programming language,

42
00:04:17,120 --> 00:04:25,600
such as MPI, MPI code generation and verification, and Haskell and Java API

43
00:04:25,600 --> 00:04:30,280
generations, and applications to the Go language

44
00:04:30,280 --> 00:04:36,240
and the Scala, and we have wide, disparate
applications with the session types so that

45
00:04:36,240 --> 00:04:36,740
you

46
00:04:36,740 --> 00:04:41,740
can see it's very easy to integrate into the
programming language

47
00:04:41,740 --> 00:04:49,240
So after this talk, I want to hear your opinion what is the maybe the application with that

48
00:04:49,240 --> 00:04:51,680
session types to your problem.

49
00:04:54,440 --> 00:05:01,720
And so, I also selected what you can
read among all the best publications not only

50
00:05:01,720 --> 00:05:09,660
by me, but also of the team, and I selected
separate papers from theoretical, and binary

51
00:05:09,660 --> 00:05:10,680
and multiparity

52
00:05:10,680 --> 00:05:18,220
session types and I talk about Scribble description language and also about the last talk which

53
00:05:18,220 --> 00:05:20,520
is about monitoring of protocols

54
00:05:20,520 --> 00:05:27,160
Actually I'm also talking about the monitoring protocol and I will talk about it, and also

55
00:05:27,160 --> 00:05:36,360
if -- if I have time, I will talk about the
code generations, and how you can apply the automata

56
00:05:36,360 --> 00:05:43,540
theory and linking with session types to analyze the Go language

57
00:05:43,540 --> 00:05:46,700
by Google end to end.

58
00:05:47,540 --> 00:05:49,480
>> So let's start!

59
00:05:49,480 --> 00:05:51,380
So five session types

60
00:05:51,380 --> 00:05:58,980
Now currently, computation of concurrency
and the communication

61
00:05:58,980 --> 00:06:03,780
is ubiquitous, and you can find the way to

62
00:06:03,780 --> 00:06:09,760
organize software is increasingly based on
communication, for example, cloud and the

63
00:06:09,760 --> 00:06:16,720
microservice and the message passing protocol, network protocol previous one is also best

64
00:06:16,720 --> 00:06:18,360
under communications.

65
00:06:18,360 --> 00:06:25,800
So questions here is how you can formally
describe, implement control, communication,

66
00:06:25,800 --> 00:06:31,800
you said communication, interaction, but they
are not divisible, but how you can formalize

67
00:06:31,800 --> 00:06:38,680
it, and reason it, and how to apply and there
is a past theory

68
00:06:38,680 --> 00:06:42,440
of mobile process developed, particularly

69
00:06:42,440 --> 00:06:49,860
in the European theory, and can be applied
to real distributed

70
00:06:49,860 --> 00:06:52,620
application and programming language.

71
00:06:52,620 --> 00:07:00,520
And these are the questions we are trying
to answer in our community.

72
00:07:00,520 --> 00:07:14,900
So this talk I will show how to manage multiparty session types can be applied to verifying

73
00:07:14,900 --> 00:07:20,060
large-scale cyber infrastructure for
E-science in US.

74
00:07:22,020 --> 00:07:29,040
I am I'm going to show you how this project - Ocean Laboratory Initiative project

75
00:07:29,040 --> 00:07:38,000
and this was run 5 years, historically, and this Ocean Observatories Initiative

76
00:07:38,000 --> 00:07:39,660
is still running.

77
00:07:39,660 --> 00:07:46,940
You can find the web page but the core project, developmental project, finished a couple

78
00:07:46,940 --> 00:07:57,100
of years ago, and we participated and applied the session types to verify this cyber infrastructure,

79
00:07:57,100 --> 00:08:00,220
which I want to a bit talk about now.

80
00:08:00,340 --> 00:08:09,020
And so this is a very big project and very
expensive project, but the aim of this project

81
00:08:09,020 --> 00:08:11,080
is extremely simple

82
00:08:11,240 --> 00:08:21,900
So you get to that real time sensor data constantly coming from both offshore and onshore and

83
00:08:21,960 --> 00:08:26,720
using bouey, submarines, and cameras, and satellites,

84
00:08:26,720 --> 00:08:30,520
and transmit this data using high-speed

85
00:08:30,520 --> 00:08:41,580
networks, so that various things and the university can use this data to analyze immediately.

86
00:08:43,680 --> 00:08:55,560
And why it is interesting to observe the oceans, because this earth is 70% are oceans, and

87
00:08:55,560 --> 00:09:00,560
they are a very, very active source of information.

88
00:09:00,560 --> 00:09:09,480
For example, not only just temperatures, but also bacteria, and circularity, and circularity,

89
00:09:09,480 --> 00:09:14,100
and also the sun and dust and the wind

90
00:09:14,100 --> 00:09:21,500
All of this information
very useful to get to it so that you can use

91
00:09:21,500 --> 00:09:31,180
to analyze for example, for example, to predict the forecasts and predict global warming and

92
00:09:31,180 --> 00:09:37,000
also predict earthquake -- so getting analyzing this

93
00:09:37,000 --> 00:09:41,140
data immediately, it's very important.

94
00:09:41,640 --> 00:09:48,960
And so, so that's these things, and so this
is a big picture of the Ocean Observatories

95
00:09:48,960 --> 00:09:58,480
Initiative and getting sensor data and from
our seas and transmit these data using very

96
00:09:58,480 --> 00:10:03,500
big cyberinfrastructure, so that they can
develop scientific

97
00:10:03,500 --> 00:10:09,300
projects, and realtime and remote controlling and things like this

98
00:10:10,520 --> 00:10:14,760
and, this is a view of that cyber infrastructure, and

99
00:10:14,760 --> 00:10:17,840
interestingly -- the interesting point of

100
00:10:17,840 --> 00:10:25,320
this project is that they build this cyber
infrastructure from scratch using methods

101
00:10:25,320 --> 00:10:33,740
with middleware, such as... I worked with the people and so what you can observe

102
00:10:33,740 --> 00:10:42,300
here is that there are loads of loads of message-passing,
and because you need to transfer the messages

103
00:10:42,300 --> 00:10:52,500
from point to point, and so that they're
use case is basically best with message-passing.

104
00:10:52,500 --> 00:11:03,500
Here we have the questions: How you can catalog, manage, describe, control, and verify this

105
00:11:03,500 --> 00:11:05,220
message passing.

106
00:11:05,880 --> 00:11:14,740
That is reason why I work with these people using the theory of multiparty session types.

107
00:11:14,740 --> 00:11:22,920
So why multiparty message passing protocol is important because we want to assure the

108
00:11:22,920 --> 00:11:25,820
correctness of the message passing

109
00:11:25,880 --> 00:11:33,580
For example, this cyberinfrastructure,
you needed to control the order of the messages

110
00:11:33,580 --> 00:11:45,660
and the synchronization, and you want to guaruntee messages are robust and not and not circular, so

111
00:11:45,660 --> 00:11:50,220
for example, deadlock freedom and liveness and also

112
00:11:50,220 --> 00:11:57,020
this cyberinfrastructure, it's
too big to verify statically, so you need

113
00:11:57,020 --> 00:11:58,140
to do something

114
00:11:58,140 --> 00:12:04,040
dynamic analysis, and monitoring, discovery, also maybe you want

115
00:12:04,040 --> 00:12:08,080
to control the message logically, for example,

116
00:12:08,080 --> 00:12:10,980
using information with the timers.

117
00:12:10,980 --> 00:12:21,440
So why did oceanography people interested in the theory and this fundamental work and

118
00:12:21,440 --> 00:12:23,520
work with us?

119
00:12:23,520 --> 00:12:32,240
Their cyberinfrastructure is very expensive,
so that it was assumed it would retain 30 years,

120
00:12:32,240 --> 00:12:39,100
so if we retain 30 years, you want it
to build the correct infrastructure, that is

121
00:12:39,100 --> 00:12:44,440
the reason we are working with them, and the part of that project.

122
00:12:45,800 --> 00:12:48,900
So why multi-party session types?

123
00:12:48,980 --> 00:12:56,380
But I want to say why type best verification
is important?

124
00:12:56,380 --> 00:13:02,640
So Robin Milner is one of the two Turing winners in the UK

125
00:13:02,640 --> 00:13:13,720
and he -- he initiated ML -- functional programming and also he created ccs, process calculus.

126
00:13:13,720 --> 00:13:21,960
>> And he said why types are important...
is that types can digest the computations,

127
00:13:21,960 --> 00:13:31,880
so as I will explain, session types can describe the communication protocol types, and why

128
00:13:31,940 --> 00:13:40,820
types are important is that you can combine the notion of types through programming language and through

129
00:13:40,820 --> 00:13:46,380
the chain easily, as you know, with Java and Haskell and Python

130
00:13:46,380 --> 00:13:54,300
Python is not a typed language, but these
kind of things can be easily integrated to

131
00:13:54,300 --> 00:13:56,180
-- to the change.

132
00:13:56,180 --> 00:14:05,240
Another thing is that types are very cheap
comparing, for example. the approach of model checking,

133
00:14:05,240 --> 00:14:06,040
because

134
00:14:06,040 --> 00:14:11,960
normally it is finished by linear type checking is finished compiled under linear type or

135
00:14:11,960 --> 00:14:15,660
polynomial type, and session types most of their verifications,

136
00:14:15,660 --> 00:14:21,160
are polynomial types, and also it is easy

137
00:14:21,160 --> 00:14:28,880
to extend, for example logical verification,
even dynamic monitoring, which I will explain now.

138
00:14:31,180 --> 00:14:39,840
And before that, I really think, and this
is ideally, I ask you to also communicate

139
00:14:39,840 --> 00:14:48,600
with academic people, because I believe that dialog between industry and academia are extremely

140
00:14:48,600 --> 00:14:57,780
important, also discover the very theoretical fundamental discovery, and the reason is

141
00:14:57,780 --> 00:15:05,820
that multiparty session types was discovered by the interaction with industry people, which

142
00:15:05,820 --> 00:15:08,620
I want to explain in a bit of detail.

143
00:15:08,620 --> 00:15:16,680
So session types, it's starts at the type
theory of the mobile process, actually quite

144
00:15:16,680 --> 00:15:22,960
a long time ago, '98, and at that time, nobody used it.

145
00:15:23,020 --> 00:15:26,720
Just a theory of the mobile process.

146
00:15:26,720 --> 00:15:35,080
But after that, whoever saw this coming and the people tried to control or verify web service

147
00:15:35,080 --> 00:15:46,680
language, and so Milner, Honda and I are invited to join W3C working group, one working group

148
00:15:46,680 --> 00:15:50,220
called choreography description language group

149
00:15:50,220 --> 00:15:53,880
And where we proposed to use session
types.

150
00:15:54,940 --> 00:16:04,960
However, their language, standardization language was very, very complicated, so that we spent

151
00:16:04,960 --> 00:16:12,540
five years to formalize the idea, because
we didn't understand what they are doing.

152
00:16:12,540 --> 00:16:13,040
[laughter]

153
00:16:13,040 --> 00:16:20,320
And so Kohei it was a bit; (he) initiated this project,

154
00:16:20,320 --> 00:16:28,740
and then he invited a couple of industry people,
and then they started a venture company called

155
00:16:28,740 --> 00:16:35,040
Pifortec, and we started a simplification
of their language called Scribble.

156
00:16:35,040 --> 00:16:39,140
And that is the original multiparty session
types.

157
00:16:39,240 --> 00:16:42,640
But what I want to show is that.

158
00:16:42,640 --> 00:16:51,640
These is the original CDL language and you
know where industry people meet and discussed

159
00:16:51,640 --> 00:17:00,280
about the standardization, it becomes extremely complicated and this is a protocol of Hello

160
00:17:00,280 --> 00:17:01,080
world.

161
00:17:01,080 --> 00:17:06,580
But, you don't understand that this the protocol of Hello world!

162
00:17:06,580 --> 00:17:13,740
Because they want to put for example, roleType, participantType, channelType and so on

163
00:17:13,740 --> 00:17:16,780
And so it's quite complicated.

164
00:17:17,860 --> 00:17:25,940
And so Kohei sent -- Kohei -- sent quite a
bit of emails to

165
00:17:25,940 --> 00:17:28,340
a couple of industry partners.

166
00:17:28,340 --> 00:17:38,080
Let's forget the CDL and start from scratch to write a very simple protocol language called scribble,

167
00:17:38,080 --> 00:17:46,480
and that is the start of that multiparty session type theory, actually, and so this Scribble

168
00:17:46,480 --> 00:17:50,860
language, I will introduce later, and everybody understands

169
00:17:50,860 --> 00:17:53,500
this is hello world protocol.

170
00:17:54,640 --> 00:18:03,640
And so here is that protocol declaration,
and the keywords and the hello world, and

171
00:18:03,640 --> 00:18:06,000
they are two persons -- You and World.

172
00:18:06,160 --> 00:18:11,400
And we send a message hello from you to world.

173
00:18:11,400 --> 00:18:17,000
And this is the type to describe the global
protocol

174
00:18:19,260 --> 00:18:29,060
And so after that, actually, I went to show
and also I'm going to show, how binary session

175
00:18:29,060 --> 00:18:37,640
types, it's extended to the multiparty session types, but very long time ago, we couldn't

176
00:18:37,640 --> 00:18:47,580
extend and we don't know how to extend to
theory of binary session types to multiparty

177
00:18:47,580 --> 00:18:55,880
session types, but using the idea with the
Scribble with CDL, we could actually extend

178
00:18:55,880 --> 00:18:56,620
to the

179
00:18:56,620 --> 00:19:04,500
multiparty session types and so we wrote the paper that accepted at POPL, top-tier conference of

180
00:19:04,500 --> 00:19:11,180
the programming language and we had quite a benefit of that engineering idea.

181
00:19:11,180 --> 00:19:19,400
So we are always welcome to getting the idea, and also, because theoretically extended and

182
00:19:19,520 --> 00:19:26,000
Scribble is promoted at one at the later group projects after that.

183
00:19:26,720 --> 00:19:35,880
And we started to work with several industry people and also currently expanding this circle.

184
00:19:37,880 --> 00:19:49,160
So now I want to show what are the session types, and actually I hope everybody here

185
00:19:49,160 --> 00:19:55,980
understands at least the binary session
types, because the idea is very simple.

186
00:19:56,420 --> 00:20:00,980
And binary means two-party session types,
OK?

187
00:20:00,980 --> 00:20:12,360
So, let's think this is online shopping,
and there are two participants, or roles,

188
00:20:12,360 --> 00:20:14,560
buyer and
seller.

189
00:20:14,560 --> 00:20:21,800
And the buyer tried to buy a book from the
seller, for example, Amazon, sending that

190
00:20:21,800 --> 00:20:31,420
message title, under this type, and then seller sends back the quote to the buyer, and then

191
00:20:31,420 --> 00:20:33,420
there are two choices.

192
00:20:33,420 --> 00:20:45,080
OK, or quit, and if we click OK, and the buyer sends an address, and then the seller sends us the variable date, and

193
00:20:45,080 --> 00:20:51,860
otherwise, if he doesn't like that quote,
he quits the protocol.

194
00:20:52,060 --> 00:20:52,720
OK?

195
00:20:52,720 --> 00:20:54,560
Everybody understand?

196
00:20:54,560 --> 00:21:00,440
And basically send and receive, and there
is a choice, and then if choice,

197
00:21:00,440 --> 00:21:03,260
one choice, will continue, otherwise quit

198
00:21:03,260 --> 00:21:04,800
that protocol.

199
00:21:06,800 --> 00:21:15,620
And so these session types from the buyer's viewpoint, written like this, OK?

200
00:21:15,620 --> 00:21:21,360
So up means !, ! means output.

201
00:21:21,360 --> 00:21:33,740
Output to string, and input is a quote, and
this plus mark means there's two choices.

202
00:21:33,740 --> 00:21:35,240
OK or quit.

203
00:21:35,240 --> 00:21:42,580
If OK, send us the link and get us the date
and end the protocol, OK?

204
00:21:42,900 --> 00:21:45,820
And then quit, end the protocol.

205
00:21:45,820 --> 00:21:48,420
So there are your choices here, OK?

206
00:21:48,420 --> 00:21:55,880
So that if you can write a UML diagram
nearly using the session types.

207
00:21:56,580 --> 00:22:01,380
Next, and then now you get to the idea.

208
00:22:01,380 --> 00:22:06,980
Interesting thing is that seller session type
is the dual.

209
00:22:06,980 --> 00:22:08,560
What do we mean dual?

210
00:22:08,560 --> 00:22:15,280
Dual is swapping output to input, input to
output

211
00:22:15,280 --> 00:22:20,260
So ! means output, input means question.

212
00:22:20,260 --> 00:22:26,980
So this is the viewpoint from the seller and
the buyer, and this ampersand, it's

213
00:22:26,980 --> 00:22:32,560
waiting a choice, so he is awaiting the choice,
OK, or quit.

214
00:22:32,560 --> 00:22:40,240
And once you type that program, using the
session types and the buyer and the seller,

215
00:22:40,240 --> 00:22:48,720
you can see there is no deadlock, because
input match output, output matches input

216
00:22:48,720 --> 00:22:54,440
and there is a choice always then waiting
a choice, OK?

217
00:22:54,440 --> 00:23:03,340
In this way, you can guaruntee deadlock
freedom using the session types, just checking

218
00:23:03,340 --> 00:23:08,240
the duality, and this comes along -- the underlying idea

219
00:23:08,240 --> 00:23:13,400
comes from linear logic by Girard and that is an important

220
00:23:13,400 --> 00:23:15,360
point of the session types.

221
00:23:16,900 --> 00:23:25,900
Now, these are the two players, two people,
but how you can extend to that managed parties?

222
00:23:26,980 --> 00:23:38,060
So, there are three parties here, and I just
extended this scenario to that another buyer,

223
00:23:38,060 --> 00:23:46,100
and now scenario is that you tried to buy
-- two buyers tried to collaborate with each

224
00:23:46,100 --> 00:23:54,560
other on sending a message and buy the book, and now, protocol becomes a managed party,

225
00:23:54,560 --> 00:24:02,620
and so seller, first the buyer sends a title
and the seller distributes the quote, both

226
00:24:02,620 --> 00:24:11,320
buyer 1 and buyer 2, and buyer 1 sends that
quote, how much he can contribute to the buyer 2,

227
00:24:11,320 --> 00:24:17,060
and then there is another choice repeating
like this, OK?

228
00:24:17,060 --> 00:24:24,680
However, how you can manage deadlock free with more than

229
00:24:24,680 --> 00:24:26,480
two parties?

230
00:24:26,480 --> 00:24:35,220
The idea is not so simple, because you may
think, this is like let's divide the binary--

231
00:24:35,220 --> 00:24:36,900
-- into binary

232
00:24:36,900 --> 00:24:38,700
in this managed party protocol.

233
00:24:38,700 --> 00:24:40,580
That doesn't work.

234
00:24:40,580 --> 00:24:42,480
Why it doesn't work?

235
00:24:42,480 --> 00:24:49,380
Because you need three separate session types, and previously, because you have three combinations:

236
00:24:49,380 --> 00:24:51,860
buyer, seller, buyer 2.

237
00:24:51,860 --> 00:24:52,360
Ok?

238
00:24:52,360 --> 00:24:56,140
And all protocol becomes split.

239
00:24:58,220 --> 00:25:00,920
And not only this protocol.

240
00:25:00,920 --> 00:25:09,220
Then this protocol becomes a type of if we
use binary session types, but what we want

241
00:25:09,220 --> 00:25:18,140
to prove is that describe and check with this multiparty session types, how you can do it

242
00:25:18,140 --> 00:25:21,560
using the idea of the session types.

243
00:25:23,720 --> 00:25:28,200
And here it's a bit technical and faster.

244
00:25:28,600 --> 00:25:36,740
So the idea comes from the choreography description language and as I told you before, and first

245
00:25:36,740 --> 00:25:37,740
of all

246
00:25:37,740 --> 00:25:44,820
you need to write the global protocol because
you wanted to give that protocol.

247
00:25:44,820 --> 00:25:51,320
For example, if there are Alice, Bob, and
Carol, and this role, and this

248
00:25:52,840 --> 00:26:05,680
type of T1 message to B, B to C, and then C
sends to A. You just described this as a type

249
00:26:05,680 --> 00:26:14,580
like this, and this examples of the choreography protocol, like A send to B, B send to C, C

250
00:26:14,580 --> 00:26:21,460
sends to A like this. This is a type which you need to describe first.

251
00:26:22,220 --> 00:26:25,320
And then next step is that.

252
00:26:25,680 --> 00:26:30,220
You need to then this to project into the
binary

253
00:26:30,220 --> 00:26:35,040
session types, so that each endpoint can

254
00:26:35,040 --> 00:26:44,340
have the interface with output and input
and the choice so if you implemented the program

255
00:26:44,340 --> 00:26:51,240
following this sequence, then each people
interact correctly.

256
00:26:51,760 --> 00:26:57,300
And, but this is a projected, because I would
be

257
00:26:57,300 --> 00:27:00,560
able to throw down, supported from the viewpoint

258
00:27:00,560 --> 00:27:06,780
of A. A sends the type of message, T1, to
B, and which

259
00:27:06,780 --> 00:27:11,980
means send B type over T1, and C sends the

260
00:27:11,980 --> 00:27:21,440
message T3, to this person, and annotated
by this participant, who am I going to send,

261
00:27:21,440 --> 00:27:25,340
and from whom you are going to receive.

262
00:27:25,340 --> 00:27:27,340
So A has a data type.

263
00:27:27,340 --> 00:27:30,400
B has this type, C has this type.

264
00:27:30,400 --> 00:27:34,480
Because these three are projected from these
global

265
00:27:34,480 --> 00:27:38,700
types, and once you get to these types, each

266
00:27:38,700 --> 00:27:47,200
participant behaves correctly, so that you
can guarantee deadlock freedom, Ok?

267
00:27:47,200 --> 00:27:48,400
However.

268
00:27:48,400 --> 00:27:50,100
This is a bit difficult.

269
00:27:50,100 --> 00:27:58,320
So maybe it's a bit difficult to explain,
but if you do not follow these global types,

270
00:27:58,320 --> 00:28:08,480
this is the bad local type which does not
follow this projection, but this is a dual with each other but

271
00:28:08,480 --> 00:28:14,880
you can see that more people are waiting and, even dual with each other, so that this is a deadlock.

272
00:28:14,880 --> 00:28:24,040
So writing global types and the project does work to check the endpoint protocol.

273
00:28:26,000 --> 00:28:34,500
So now I'm going back to the sea again, and this this is the ocean observatory initiative

274
00:28:34,500 --> 00:28:35,940
institution,

275
00:28:35,940 --> 00:28:42,160
and in front of the sea, because they like
sea, and this is the pier by University of

276
00:28:42,160 --> 00:28:43,040
San Diego, I

277
00:28:43,040 --> 00:28:54,220
think, and they started the oceanography first
in the world, and this is the storage

278
00:28:54,220 --> 00:28:56,280
which stores the instruments.

279
00:28:57,000 --> 00:29:04,760
and we feed with them and worked with them and they developed some architecture with their

280
00:29:04,760 --> 00:29:05,800
developers.

281
00:29:05,800 --> 00:29:13,220
And this is my student, and this is my post
doc who developed their protocol.

282
00:29:13,220 --> 00:29:19,800
And so this work, and so --
[laughter]

283
00:29:19,800 --> 00:29:28,640
I want to use these global types and the global type is ... these multiparty session types are used in various

284
00:29:28,640 --> 00:29:37,700
ways and I only introduce one way today at
the main applications, and the rest I will

285
00:29:37,700 --> 00:29:39,340
quickly explain today.

286
00:29:39,340 --> 00:29:41,440
I hope I have time to manage it.

287
00:29:41,700 --> 00:29:50,000
So first of all, global type, its projected
to local types, but these local types looks

288
00:29:50,000 --> 00:29:58,200
like the state machine, and using this information we write a program for example Alice, Bob,

289
00:29:58,200 --> 00:30:06,720
Carol, and check incoming and outgoing messages correct against these local types

290
00:30:06,720 --> 00:30:10,340
That is the application I will explain.

291
00:30:10,880 --> 00:30:14,580
And before that, I want to briefly explain
about what

292
00:30:14,580 --> 00:30:18,080
is Scribble language, and Scribble language

293
00:30:18,080 --> 00:30:30,020
is the -- Scribble language -- is a kind of programming language to describe that multiparty session types, and as I said

294
00:30:30,020 --> 00:30:35,420
session types start from the types of the
theory, of the concurrency,

295
00:30:35,420 --> 00:30:43,980
where we write all these papers with Greek-letters and then industry partner said that they don't want

296
00:30:43,980 --> 00:30:45,980
to read Greek-letters paper

297
00:30:45,980 --> 00:30:50,720
and they want to read this kind of notations,

298
00:30:50,720 --> 00:30:57,320
so we developed this protocol in the description language with them, and they designed them,

299
00:30:57,320 --> 00:31:07,960
and then automatically you can -- you can
project to it, but before -- because I don't

300
00:31:07,960 --> 00:31:15,860
have time, I really want to quickly show what is that application here, and so, this is

301
00:31:15,860 --> 00:31:21,760
a protocol we try to specify from the Ocean Observatories Initiative.

302
00:31:22,100 --> 00:31:25,580
Project: I show here.

303
00:31:26,280 --> 00:31:31,160
And so this is the Scribble web page.

304
00:31:31,160 --> 00:31:39,000
If you are interested after my talk, because it is quite a big project that I will explain

305
00:31:39,000 --> 00:31:39,720
later.

306
00:31:39,720 --> 00:31:50,200
And this is web page that you can test Scribble protocol and then you can check under whether

307
00:31:50,200 --> 00:31:56,200
this is correct, and you can project this
is automatically like this, so this is a bit

308
00:31:56,200 --> 00:31:57,140
of an education tool.

309
00:31:57,140 --> 00:32:04,680
So what I want to show today is how we try to

310
00:32:04,680 --> 00:32:08,560
verify that using the session types architecture,

311
00:32:08,560 --> 00:32:18,140
this protocol between the customer agent and the provider agent, and interactions specification

312
00:32:18,140 --> 00:32:25,480
of the ocean observatory, and so as you can see, the developer wrote about this kind of

313
00:32:25,480 --> 00:32:27,120
UML diagram.

314
00:32:27,120 --> 00:32:29,120
It is very complicated

315
00:32:29,120 --> 00:32:37,420
and it is very ambiguous, and it is not clear what they want to do with this kind of -- on

316
00:32:37,420 --> 00:32:44,940
the natural language explanation, so what
we did is that we that actually tried to write

317
00:32:44,940 --> 00:32:54,380
down, and before that, I want to show a
bit monitor architecture of this OOI and the

318
00:32:54,380 --> 00:32:59,180
what they do is that they analyze and control
this

319
00:32:59,180 --> 00:33:03,180
kind of message passing, and using various

320
00:33:03,180 --> 00:33:13,980
kinds of hierarchical architectures, and you can see how Scribble is located at the bottom

321
00:33:13,980 --> 00:33:26,220
part: And they can intercept in the various
sophisticated policies and sent out with that

322
00:33:26,220 --> 00:33:34,800
architecture and decide to--sorry--whether you can throw

323
00:33:34,800 --> 00:33:36,700
away and

324
00:33:36,700 --> 00:33:40,460
the message that is orchestrated, finally, can control whether

325
00:33:40,460 --> 00:33:42,460
you can throw away messages or not.

326
00:33:42,460 --> 00:33:48,160
This is the way that you can integrate a lot of different tools and ideas.

327
00:33:48,160 --> 00:33:50,620
That was part of the Ocean Observatories Initiative
Tool.

328
00:33:50,620 --> 00:33:55,020
But before that, I want to go back to our
stuff.

329
00:33:59,540 --> 00:34:08,280
And so, if you use that session types, you
can write this kind of ambiguous protocol

330
00:34:08,280 --> 00:34:14,680
very clearly and first of all, you declare this is a multiparty protocol.

331
00:34:14,680 --> 00:34:22,120
Actually only two roles, but negotiate
role communicator as C. Role producer as P.

332
00:34:22,120 --> 00:34:25,120
And C and P are abbreviations.

333
00:34:25,660 --> 00:34:33,880
Next, we can write that C gets a message and that this is a submessage and

334
00:34:33,880 --> 00:34:39,060
operations is a propose can be sent from C to P and there

335
00:34:39,060 --> 00:34:45,600
is a choice after P, and then for example,
accept and confirm, or reject, and propose

336
00:34:45,600 --> 00:34:46,820
are like this.

337
00:34:46,820 --> 00:34:53,400
You can add these kind of things and then
choice can be nested and also you can not

338
00:34:53,400 --> 00:35:01,040
understand probably the declaration, but there is the causation of this protocol so that you

339
00:35:01,040 --> 00:35:09,740
can choose stop or because of the protocol, you can try and try many times like this

340
00:35:09,740 --> 00:35:18,640
And the next step is that two you can automatically project the global type to local type by checking

341
00:35:18,640 --> 00:35:26,620
the global type is correct, and this is that projection from the viewpoint of consumer, and the basically

342
00:35:26,620 --> 00:35:32,580
just chop that view of the global types to
the local types.

343
00:35:33,800 --> 00:35:42,660
And then you generate the state machine, and so this is that corresponding, this corresponding

344
00:35:42,660 --> 00:35:50,700
with these local types and so that you can
check that incoming and outcoming messages

345
00:35:50,700 --> 00:35:53,660
correct against this state machine.

346
00:35:54,800 --> 00:36:00,720
And this is Scribble and the web page, and I show it and we have a GitHub and various

347
00:36:00,720 --> 00:36:07,600
source files can be get from here, and
we have several applications based on this,

348
00:36:07,600 --> 00:36:15,100
but probably I'm not sure how much time I
have remaining, but let's see.

349
00:36:20,900 --> 00:36:28,840
And this is the big thing of the OOI so that
we can finally control

350
00:36:28,840 --> 00:36:32,380
all of these kind of things by underwater vehicles and this

351
00:36:32,380 --> 00:36:40,980
is the pictures, and so I'm -- this is that
interface of the OOI so you can get this message

352
00:36:40,980 --> 00:36:42,700
constantly.

353
00:36:44,940 --> 00:36:59,600
So I want to show the demo of that monitoring, how you use the Scribble to monitor the message

354
00:36:59,600 --> 00:37:03,920
and very quickly to two minutes.

355
00:37:04,000 --> 00:37:15,740
[prepping demo]

356
00:37:15,740 --> 00:37:20,780
So this is an RPC protocol in between
the Scribble

357
00:37:20,780 --> 00:37:25,580
language and this is the Python code, endpoint code, you

358
00:37:25,580 --> 00:37:33,340
want to monitor in it and you can see that
there is something like -- sorry -- I think

359
00:37:33,340 --> 00:37:35,680
it's better if I stop it

360
00:37:35,680 --> 00:37:37,400
its a bit quick.

361
00:37:40,360 --> 00:37:47,200
So this is the that global protocol which
tries to describe the interaction with the

362
00:37:47,200 --> 00:37:53,380
provider and the requester and first you needed to write this kind of protocol which you want

363
00:37:53,380 --> 00:37:55,340
to monitor.

364
00:38:00,020 --> 00:38:08,620
And then this is a Python code which you want to monitor and whether they correctly behave

365
00:38:08,620 --> 00:38:10,620
or not.

366
00:38:12,220 --> 00:38:18,620
And you can see several other operations such as accept and reject, and invite.

367
00:38:18,620 --> 00:38:23,080
We want to check whether the message is correct or not.

368
00:38:23,080 --> 00:38:30,140
And this is some kind of wrapper and Hello client and now we tried to run the

369
00:38:30,140 --> 00:38:35,720
batch machine of the OOI, and so first you

370
00:38:35,720 --> 00:38:45,680
needed to execute the tool and batch machine, and then Python monitoring,

371
00:38:45,680 --> 00:38:48,500
inside this capability.

372
00:38:48,700 --> 00:38:58,140
[running demo]

373
00:38:58,140 --> 00:39:00,140
over here.
[running demo]

374
00:39:00,300 --> 00:39:06,980
[running demo]

375
00:39:07,140 --> 00:39:12,920
And then so now we have hello client,

376
00:39:17,280 --> 00:39:26,820
and so, then, now you can see message is correct

377
00:39:26,820 --> 00:39:35,660
monitor or not, and returns a status, such
as correct, and correct, and correct, and

378
00:39:35,660 --> 00:39:47,480
you can correct message input and output and now you change this correct program to the

379
00:39:47,480 --> 00:39:57,060
wrong incorrect program, changing accept to
invite, and then then monitor again.

380
00:39:59,380 --> 00:40:03,580
And the first one is correct and then you
can show

381
00:40:03,580 --> 00:40:07,340
the next message is incorrect like this, and

382
00:40:07,340 --> 00:40:14,440
like this by monitoring the message against the Scribble, you can guarantee that you can

383
00:40:14,440 --> 00:40:16,440
detect the bad message,

384
00:40:16,440 --> 00:40:21,660
and protocol and this is quite a simple application for that session test.

385
00:40:21,660 --> 00:40:27,520
Like this, we worked with the OOI people

386
00:40:27,520 --> 00:40:34,800
And, I'm showing this -- sorry, where are

387
00:40:34,800 --> 00:40:36,660
it going?

388
00:40:37,120 --> 00:40:57,040
[prepping video demo]

389
00:40:57,440 --> 00:41:05,220
And so, I show only one application on dynamic monitoring, but this general idea of global

390
00:41:05,220 --> 00:41:12,700
protocol and this projection can be applied to various different applications which I

391
00:41:12,700 --> 00:41:19,300
want to show a bit quickly, and I show the
dynamic monitoring, and also, you can of course

392
00:41:19,300 --> 00:41:27,380
use the session types by type-checking, using the session types as types, and write some

393
00:41:27,380 --> 00:41:28,200
programs

394
00:41:28,200 --> 00:41:34,820
such as Haskell and do the type-checking integrated session types and so and so on that you can guarantee

395
00:41:34,820 --> 00:41:37,840
that it will involve many participants.

396
00:41:38,640 --> 00:41:46,880
Also, interesting application is that you
can generate the code for that global types,

397
00:41:46,880 --> 00:41:53,620
and for this we have two works of the MPI
code generation and Java code generation.

398
00:41:53,620 --> 00:41:58,000
Probably, I cannot do the demo, because I
have a shortage

399
00:41:58,000 --> 00:42:02,700
of time today, and so also, you may think

400
00:42:02,700 --> 00:42:13,020
the other way around, not writing global
type, but generating global types from the

401
00:42:13,020 --> 00:42:14,400
communication

402
00:42:14,400 --> 00:42:17,720
of the program, may be useful.

403
00:42:18,040 --> 00:42:26,140
Actually, we have the work of this, and we
applied this to two different applications

404
00:42:26,140 --> 00:42:29,580
which I just want to very quickly show,

405
00:42:29,580 --> 00:42:31,340
and
this slide I'll skip.

406
00:42:31,340 --> 00:42:39,840
And basically session types have mathematical
correspondence with communicating automata.

407
00:42:39,840 --> 00:42:47,740
I don't know if you know the communicating
automata, but automata which can describe

408
00:42:47,740 --> 00:42:57,020
input and output and asynchronous messages
and I was very shocked, these entity I discovered

409
00:42:57,020 --> 00:43:05,040
in very old literature of the communicating
automata, which exactly corresponds with that

410
00:43:05,040 --> 00:43:07,040
of binary session types.

411
00:43:07,180 --> 00:43:15,580
And the communicating automata is that basically it is very powerful and it is undecidable

412
00:43:15,580 --> 00:43:16,420
to check

413
00:43:16,420 --> 00:43:24,380
whether this communication is deadlock-free
or not, but if you restrict that,

414
00:43:24,380 --> 00:43:28,440
this communicating automata, with certain

415
00:43:28,440 --> 00:43:35,240
kinds of conditions, which exactly similar
with the session types, deadlock-detection

416
00:43:35,240 --> 00:43:36,240
becomes

417
00:43:36,240 --> 00:43:45,080
decidable and actually this was proved before
the session types appeared, so that mathematically

418
00:43:45,080 --> 00:43:49,680
good structure arrived in the different areas,

419
00:43:49,680 --> 00:43:58,240
That was one surprise thing
when you do this kind of research work.

420
00:43:58,700 --> 00:44:02,300
And, so on this I may skip a bit.

421
00:44:02,300 --> 00:44:10,600
Interestingly we applied this this approach
to this legacy code analysis of a bank application,

422
00:44:10,600 --> 00:44:12,240
but I will skip it.

423
00:44:12,240 --> 00:44:22,020
And I want to show one example of how you
can build the session types from the communicating

424
00:44:22,020 --> 00:44:27,180
automata, so there are -- so natural question is whether you can

425
00:44:27,180 --> 00:44:31,100
extend binary approach to the multiparty approach?

426
00:44:31,100 --> 00:44:36,120
And the right-hand side is the communicating automata,

427
00:44:36,120 --> 00:44:40,400
and you cannot see how they interact, but

428
00:44:40,400 --> 00:44:48,660
you can imagine this kind of flow of the message, it's analyzed by the source code, for example,

429
00:44:48,660 --> 00:44:52,940
Java or something, and then you can get to this

430
00:44:52,940 --> 00:44:56,600
automata, but you don't know how they interact

431
00:44:56,600 --> 00:45:02,640
correctly or deadlock-free, but we could
build the

432
00:45:02,640 --> 00:45:06,980
session types by using a certain kind of theory

433
00:45:06,980 --> 00:45:17,960
and decidable and then you can check whether this automata for party interaction is correctly

434
00:45:17,960 --> 00:45:27,800
globally organized and then translated into that BPMN choreography language.

435
00:45:28,160 --> 00:45:35,400
This is just a couple of applications and
I just want to show one quick application

436
00:45:35,400 --> 00:45:41,020
to the ...

437
00:45:41,020 --> 00:45:43,940
Go language by Google.

438
00:45:43,940 --> 00:45:52,520
And I don't know if you know -- oh, maybe
it's better to show that a little bit fast.

439
00:45:52,800 --> 00:46:01,660
[prepping video]

440
00:46:01,920 --> 00:46:09,540
I guess many of you know that Go programming language by Google, which is based on the

441
00:46:09,540 --> 00:46:15,100
process calculus such as Csp and pi-calculus, basicallly

442
00:46:15,100 --> 00:46:20,300
they are based on message passing and channel communications,

443
00:46:20,300 --> 00:46:29,780
and it is written here and their communication is basically -- they encourage to use message-passing

444
00:46:29,780 --> 00:46:32,760
instead of shared communications.

445
00:46:33,000 --> 00:46:42,080
And we applied this approach to analyze deadlock detection

446
00:46:42,080 --> 00:46:45,600
and I have five minutes, so that I will show

447
00:46:45,600 --> 00:46:47,320
the demo here.

448
00:46:47,860 --> 00:46:53,780
[opening demo]

449
00:46:54,020 --> 00:47:03,860
So, this is the Go interpreter, and this
is Go programming language.

450
00:47:03,860 --> 00:47:12,980
You can see send and receive work
and so this is -- this describes that

451
00:47:12,980 --> 00:47:14,980
basically.

452
00:47:14,980 --> 00:47:18,700
Sorry, it's made too quick.

453
00:47:21,280 --> 00:47:28,800
And, This is the deadlock, because send and receive are mismatching, and if you run this

454
00:47:28,800 --> 00:47:39,060
program by Go interpreter, you can see send-to, and receive-one, so it is obviously deadlock.

455
00:47:39,180 --> 00:47:44,620
And, then, actually Go has a runtime deadlock checker.

456
00:47:44,620 --> 00:47:52,120
So you cannot write, because they detected a deadlock, but their deadlock analysis is

457
00:47:52,120 --> 00:47:52,900
first of all

458
00:47:52,900 --> 00:48:00,440
dynamic, and cannot capture that partial deadlock, and we tried to solve this

459
00:48:00,440 --> 00:48:04,560
using the synthesis of the session types.

460
00:48:06,820 --> 00:48:15,200
And now we change the protocol just using the while loop like this, and then this is a

461
00:48:15,200 --> 00:48:18,180
still a mismatch of course -- protocol.

462
00:48:18,180 --> 00:48:24,340
And working, working, working, which means that because each Go routine that's running,

463
00:48:24,340 --> 00:48:28,020
they're deadlock (analysis) dynamic tool

464
00:48:28,020 --> 00:48:31,920
cannot capture this deadlock, OK?

465
00:48:31,920 --> 00:48:37,500
So now we are trying to use our Go tool which generates

466
00:48:37,500 --> 00:48:43,180
the automata from each Go routine and build a global type

467
00:48:43,180 --> 00:48:48,560
so that  you can check whether the Go language

468
00:48:48,560 --> 00:48:54,460
or Go program is a deadlock-free or not by static analysis.

469
00:48:54,460 --> 00:49:03,520
And so first we create the state machine,
from each Go routine and with this we can

470
00:49:03,520 --> 00:49:04,600
show that

471
00:49:04,600 --> 00:49:06,040
first of all

472
00:49:09,060 --> 00:49:10,900
and, like this,

473
00:49:10,900 --> 00:49:17,920
You can create just a state machine from each Go routine code, and then use synthesis to

474
00:49:17,920 --> 00:49:21,600
try to find out the matching between input and

475
00:49:21,600 --> 00:49:23,960
output, and

476
00:49:23,960 --> 00:49:28,700
using our session types theories.

477
00:49:29,680 --> 00:49:31,700
And so we check it ...

478
00:49:31,960 --> 00:49:40,240
[checking]

479
00:49:40,480 --> 00:49:51,380
and generate it, and then here I can say -- sorry -- I can say here we said this

480
00:49:51,380 --> 00:49:52,040
checking

481
00:49:52,040 --> 00:49:55,660
it's incorrect, because it doesn't -- input
and

482
00:49:55,660 --> 00:50:01,020
output -- doesn't match, and it is not also
well-formed

483
00:50:01,540 --> 00:50:06,140
So what you can describe visually in the session type

484
00:50:06,140 --> 00:50:07,580
is that ... ,

485
00:50:09,280 --> 00:50:17,160
because you can generate from these kind of global types, using the session type theory,

486
00:50:17,160 --> 00:50:23,020
and you can see there are two ends which is incorrect global types.

487
00:50:23,020 --> 00:50:24,620
So this shows a deadlock.

488
00:50:24,620 --> 00:50:29,660
I cannot explain details with this time.

489
00:50:31,060 --> 00:50:39,260
And now we change the correct program, only we have send and one receive and then now we do

490
00:50:39,260 --> 00:50:48,520
the same things, and generate and check now, whether they are compatible or not using the

491
00:50:48,520 --> 00:50:55,800
this -- our automata theory, and then it returns correct now?

492
00:50:58,060 --> 00:51:00,060
I think so.

493
00:51:00,680 --> 00:51:01,420
OK.

494
00:51:02,460 --> 00:51:15,400
And since its check is true and now we can build this tool using the .dot applications,

495
00:51:15,400 --> 00:51:22,760
and now because we see that this interaction is correct, like this.

496
00:51:22,760 --> 00:51:27,800
And so I wanted to show another real code generation

497
00:51:27,800 --> 00:51:33,020
example, which applied to Scribble to Java directly,

498
00:51:33,020 --> 00:51:39,200
but probably I don't have time now?

499
00:51:40,480 --> 00:51:46,940
And so maybe I should probably stop, or I
can just quickly show it.

500
00:51:46,940 --> 00:51:49,720
>> ZEESHAN: ...

501
00:51:50,440 --> 00:51:55,220
>> Can I do, or maybe better to have questions?

502
00:51:55,220 --> 00:51:55,720
>> ZEESHAN: Yeah.

503
00:51:55,720 --> 00:52:03,640
>> Yes, OK, OK, because it's probably better to -- and so, anyway,

504
00:52:03,640 --> 00:52:10,060
so I will finish my talk here, and every information

505
00:52:10,060 --> 00:52:17,480
that I said, you can see from the web page, but it's quite probably difficult to understand

506
00:52:17,480 --> 00:52:22,580
what tools and papers you should read, and it also depends

507
00:52:22,580 --> 00:52:25,300
on interest, you know, if you want to use

508
00:52:25,300 --> 00:52:32,480
the session types to verify and specify the
message passing, and you are very welcome

509
00:52:32,480 --> 00:52:40,380
to directly send an email to me and so that we can start a really good collaboration

510
00:52:40,380 --> 00:52:42,180
and thank you very much

511
00:52:42,180 --> 00:52:52,980
[applause]

512
00:52:52,980 --> 00:52:56,460
>> ZEESHAN: We have time for a couple of questions and then head out for lunch.

513
00:53:02,240 --> 00:53:08,420
>> So, you mentioned that one of the benefits of using session types compared to model checking

514
00:53:08,420 --> 00:53:15,560
in like CCS or pi-calculus or CSP is that
you don't have the same kind of (state) space explosion

515
00:53:15,560 --> 00:53:19,080
that you would if you were doing model checking in a process calculus.

516
00:53:19,080 --> 00:53:22,420
Do you have any intuition for sort of like
where that boundary is?

517
00:53:22,420 --> 00:53:25,620
Where the model checking approach isn't

518
00:53:25,620 --> 00:53:26,500
going to be as useful

519
00:53:26,500 --> 00:53:29,520
because for a lot of the examples that you presented, I think

520
00:53:29,520 --> 00:53:33,060
you could do the same kind of static analysis and produce something in

521
00:53:33,060 --> 00:53:33,900
one of these process

522
00:53:33,900 --> 00:53:37,560
calcules -- calculus -- calculi -- and run
them through a model checker, and sorta do

523
00:53:37,560 --> 00:53:39,260
the same kinda of checks, and so I would

524
00:53:39,260 --> 00:53:42,820
be interested to hear if you have a sort
of have an idea of sorta where that becomes

525
00:53:42,820 --> 00:53:45,820
untenable, where you sorta have to do this type-based approach instead?

526
00:53:45,820 --> 00:53:49,260
>> Nobuko:Yes, yes, so we actually have the publication

527
00:53:49,260 --> 00:53:55,340
to to the TACAS this year on linked model
checking and session

528
00:53:55,340 --> 00:54:01,900
types and we used a model checker and also a session

529
00:54:01,900 --> 00:54:07,280
type checker to run the benchmark, which 
is

530
00:54:07,280 --> 00:54:08,440
good.

531
00:54:08,440 --> 00:54:19,520
And also, an automata approach, in TACAS 2016, so this year's TACAS paper and compare.

532
00:54:19,520 --> 00:54:23,400
Actually some kind of checking, you can

533
00:54:23,400 --> 00:54:30,780
use model checking and some of the examples, model checking scales very well, because,

534
00:54:30,780 --> 00:54:35,380
now, it is out of bounds, but certain kinds of

535
00:54:35,380 --> 00:54:37,380
normal kinds of session types

536
00:54:37,380 --> 00:54:45,120
structure between the program language, still type-checking scales much faster than this,

537
00:54:45,120 --> 00:54:47,360
and this is really depends on

538
00:54:47,360 --> 00:54:49,140
the examples.

539
00:54:49,180 --> 00:54:55,780
And actually, I said generally, you know,
session types scale well, but complicated

540
00:54:55,780 --> 00:54:57,000
examples,

541
00:54:57,000 --> 00:55:03,800
and because of the effort of model checking people, it may run sometimes faster for big

542
00:55:03,800 --> 00:55:04,520
examples.

543
00:55:04,520 --> 00:55:07,840
Actually there are many interesting big examples.

544
00:55:07,840 --> 00:55:08,680
And so,

545
00:55:08,680 --> 00:55:10,220
Golang, we have

546
00:55:10,220 --> 00:55:18,180
our next work, which we used -- actually --
more like symbolic semantics, because

547
00:55:18,180 --> 00:55:19,420
session types

548
00:55:19,420 --> 00:55:21,340
are too limited.

549
00:55:21,340 --> 00:55:22,020
So,

550
00:55:22,020 --> 00:55:25,080
there are various links of the types

551
00:55:25,080 --> 00:55:27,160
of the pi-calculus and

552
00:55:27,160 --> 00:55:28,760
the session types, and so,

553
00:55:28,760 --> 00:55:29,660
this is a

554
00:55:29,660 --> 00:55:30,800
really good question.

555
00:55:30,800 --> 00:55:31,740
Thank you.

556
00:55:31,740 --> 00:55:32,440
Yes.

557
00:55:36,260 --> 00:55:38,040
>> ZEESHAN: Any other questions?

558
00:55:40,040 --> 00:55:42,900
All right, thank you, that's good.

559
00:55:43,180 --> 00:55:45,840
[applause]

