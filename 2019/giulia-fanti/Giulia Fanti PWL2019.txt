    Privacy Vulnerabilities in the Peer-to-Peer Network of Cryptocurrencies
    - Giulia Fanti
    Zeeshan: Hello, everyone, we'll take a minute to get everybody inside. If you're outside, come inside, and we have a lot of chairs available. Come out to this side. Fit in. You know, we want everybody to be as comfortable as possible for the next talk.
    How is everything so far? First talk really good? Fun?
    [applause]
    
    
     AUDIENCE:  Can we hum still?
    >> You can hum. Maybe Giulia will involve humming. All right, we've got a few more people coming on in.
    All right, I'll start with the in
    
    Giulai Fanti is here all the way from picksburg where I'm also living as well. We wanted to have her at the last Papers We Love conference.
    Twoeer ago, and we had Justin Sherry, also a great speaker and she's the one who told me, you have to have Giulai. She publishes everything. We haven't had anything aren't cryptocurrencies, and we really wanted to hit a on that topic this year and Giulia is the best at that.
    
    [applause]
    
    OK, thank you all for coming. So as Zeeshan mentioned, I'm working on topics that are a little bit different from what we heard in the last talk, so in particular one of the difference sincerely that I'm one of those weirdos who deals with continuous domain math, rather than discrete domain. And today I'm going to be talking to you about anonymity problems that arise in cryptocurrencies peer to peer networks. So many of you may have heard about Bitcoin being portrayed as an anonymous or untraceable cryptocurrency so I wanted to include my favorite clip about Bitcoin of this is from a TV show called Almost Human.
    Bitcoin, totally untraceable. How much she got on there? 4,999
    [laughter]
    OK, someone has a lot of Bitcoins. So this notion of Bitcoin as an untraceable currency is of course eminently false.
    And this talk is going to be about one of the ways in which people can trace cryptocurrency users by exploiting properties of the underlying network that it runs on.
    So I'm going to start with a very brief primer on how Bitcoin works, and this is actually similar to the way that a lot of cryptocurrencies work, because many of them have actually just forked Bitcoin.
    So users in Bitcoin are connected over a peer to peer network of TCP links, and users are identified by public keys, so these are like pseudonyms, your money, coins are also identified. So here I'm oversimplifying a little bit, but when Alice wants to send money to Bob, she first generates a transaction message that says Alice, identified by her public key, sends some money to Bob identified by his public key and once she's generated this message, she starts broadcasting it over the network. So Alice sends it to her neighbors over the graph, they send it to their neighbors and so forth, until everybody in the network has this message and notice she's not sending it to Bob. This is a one to many broadcast, everyone should receive it. And once nodes receive this transaction, they can start racing to append it to the global public ledger of all the transactions, which we call the blockchain.
    OK, so what is about this has privacy implications? Well, -- sorry, there's a bit of an echo.
    So notice that users in this network have multiple identities, OK? So the first identity is your public key.
    Second identity is your IP address.
    And the third, of course, is your actual real-world identity. So the IP address is used in the P2P network so that you know how to connect to and how to structure the network. The public key is used in the blockchain to identify you as you're trying to transact money, and your real-world identity is theoretically used nowhere, unless you're doing something dumb.
    So if any of you have watched movies about con artists, you know that if you have multiple entities, they should never be connected to each other. And. The author in the original cryptocurrency paper, and in fact this has been a big area of research, so in the last, you know, 8eer, I would say, so users -- there's been a lot of studies showing how you can link public keys to people's real-life identities and also link different public keys that belong to the same person to each other.
    OK? So how can we do this? Well, intuitively, the idea is that because you have this blockchain, which is just a public list of every transaction that's ever happened, you can generate a graph that says, OK, this address sent money to this address, sent money to this address, and you can start clustering nodes, and more problematically, if you see that one public key is making transactions with kind of easy to identify entities, like, for example, let's say I go buy a muffin at the bakery on 5th street with Bitcoins, and then I later go buy, I don't know, rare animals on the internet, that starts to narrow down who I could possibly be. So people have used this to actually deanonymize users. And the problem here is that if you figure out the real identity of someone's public key, you can see the entire history of every transaction they've ever done, right? So this would be a huge problem? Like any modern financial system, like right now, with credit cards at best you have -- well, in theory, the only the credit card company is supposed to see your transaction history, of course we know that's not the case. But the problem with these cryptocurrencies is they're revealing this to everyone. Like any person on the street can do this analysis. So typically when people talk about the privacy vulnerabilities in cryptocurrencies, this is what they're talking about. They're talking about this graph analysis from the blockchain. In our work we looked at a different class of vulnerabilities at a lower paper, which is the peer-to-peer network. In particular, we were looking at can we link a user's public key to their IP address, OK? And on their own, like maybe knowing someone's IP address isn't super helpful but it can be used to help figure out your location and in some cases it can be used to help identify you perhaps with the help of an ISP or an employer or whatever. So being able to recover someone's IP address is actually fairly important in terms of privacy implications.
    So in this talk I'm going to start by telling you about a few papers studying how to break privacy on the peer-to-peer network, so how to link someone's IP address to their public key and then I'll talk about some recent work that we did trying to fix this problem.
    OK. So I'm going to start by talking about some early attack, and so the time scale of all of this work is much more recent. So here by early attacks, I mean 2014. And these were papers that came out of the security community, OK? So around 2014, people started realizing, we have this peer-to-peer network that all of these cryptocurrencies are running on and nobody is really studying it very much. It's been basically ignored and this could in principle be a vector for attacks. So the attacks in these papers have a similar flavor to one another. The basic idea is the following ... our attackers or our researchers are going to set up a super-node or an eavesdropper that makes a connection to every node in the network, OK? Now, when Alice generates one of her transaction messages, she's going to send it to each of her peers on the network and because this eavesdropper looks just like anyone else, she's going to send it to the eavesdropper, as well.
    So if I'm an eavesdropper and I want to know the IP address of who generated this transaction, my best bet is to just point at the first person who sends me this transaction. So notice that Alice's peers are also forwarding to the eavesdropper but probably they're going to forward it later, OK? Now, this doesn't always work, OK? And why does it not work? It doesn't always work, because Alice is not sending her message to all of her peers at the same time.
    In practice, these messages are sent with some random jitter, OK, so I might send to you at like .3 seconds after I get the message and for you I might send it 2 seconds after I get the message. There's some randomness. So what can happen is that Alice sends the message to her neighbor and the neighbor sends it to the eavesdropper before Alice herself does, and this is going to reduce the eavesdropper's probability of guessing the source correctly, OK? So so the researchers recognized this and were trying to figure out what can we do this about this? So there's a pretty easy solution, which is to make more eavesdroppers, and you can run this from different ports or different IP addresses, whatever. So what they did is set up a bunch of these mini eavesdroppers, and each of these is going to make a connection to each of the nodes in the network. So what do we have now? We have spaghetti.
    We have that when Alice tries to product cast her transaction, in this particular example, 3 out of 5 of her connections are to the eavesdropper, so with probability 3/5, the first message that she sends will go to the eavesdropper, rather than to one of her peers, OK?
    So the rough idea of these researchers' work was that as they increased the number of these mini eavesdroppers, they can control the probability of being able to correctly guess the true source of a transaction.
    OK. So -- and they had some results -- like, they decided to limit themselves to 50 mini eavesdroppers, which seems kind of high.
    And doing that, they were able to deanonymize between 11 to 34% of users, including those that were behind a NAT, OK? So in the previous examples we were kind of assuming that all of these had public-facing IP addresses, but in reality, the majority of cryptocurrency users are actually behind a NAT and even in that case they were still able to deanonymize such a high fraction.
    So this was kind of a big deal. People were worried about this. People were talking about it on forums and the Bitcoin community in particular decided to do something about it. And so, to their credit, Bitcoin core responded very quickly. So by 2015, they had a new protocol in place that was meant to address this issue.
    So to understand what the new protocol is, I want to go a little bit more into detail into what was done before this shift, OK? So before 2015, the protocol that they were using was called Trickle, and I'm going to give you kind of a cartoon version of how Trickle works, this isn't exactly correct, but it's close. So under Trickle, you would order your neighboring peers in some random order. So I choose some permutation over my peers, and I'm going to run a discrete time clock and at each tick of my clock I'll send my message to the next individual in that permutation. So I'm sending the message in some random order to my peers. With a fixed delay in between.
    Now, when the Bitcoin Core developers fixed this problem, they introduced a new protocol called Diffusion and Diffusion, each node will draw independent exponential random variables on each edge and send the message when that clock ticks, OK? So you wouldn't think of it anymore as like a discrete time process. This is continuous time, OK?
    So -- so if you actually look at the commit logs, you can see a timeline. You can see we're doing this for privacy reasons. But it doesn't explain why they moved from Trickle to Diffusion and to us it wasn't obvious that Diffusion has sufficiently different privacy properties than Trickle. So the question that my colleague and I set out to answer was does diffusion provide stronger anonymity than trickle spreading? Hand we wanted to understand this theoretically. So oftentimes when you're trying to analyze graph problems, usually getting results on general graphs is hard, so often what we do is run simulations to check if they hold on more complicated classes of graphs. So we did that in our work and started by looking at d-regular trees. So a d-regular tree is where every node has the same degree as d, OK? And this is a very simplified class of graphs, but actually it's not a terrible model for cryptocurrency peer to peer networks.
    Why is that?
    It's because a lot of the cryptocurrency peer-to-peer network are random sparse graphs, so as we're building the graph, I'll choose a few nodes, let's say 10 nodes to out of tens of thousands of nodes. so if I look in a local neighborhood of myself, like a few hops, that graph is likely to look like a tree, in that there's no cycles. And this holds with high probability.
    So trees are actually a pretty good model for this, and we'll see later that the simulations kind of back up this modeling choice. So even though this seems like we're making our lives way too easy, it actually turned out to be a pretty good predicter of what happens in the real world. So remember our adversarial model here is we have this eavesdropper who's creating an arbitrary number of connections, we'll call it theta, to each node in the network.
    So this is our graph structure. Now, to actually analyze privacy properties, you need to have some kind of metric, you need to know, like, what are we studying? So our anonymity metric here was probability of detection.
    So we're trying to compute the probability of our eavesdropper at being able to identify the correct source given two pieces of information.
    The first piece of information is the set of observed time stamps, OK, so the eavesdropper is getting theta time stamps for each mode of the message and it has access to all of those. So here, for example, if theta is equal to 1, these taos are representing the same stamp of the time of which each of these forwards the message to the adversary, and the second piece of information we give the adversary is the graph structure.
     in a lot of cryptocurrencies -- a lot of cryptocurrencies try to hide this information or make it difficult to figure out what is the graph topology of the peer-to-peer network and they do this for privacy reasons, but there have been of course attacks where people have been able to recover parts or even the entirety of the graph topology. So it's actually pretty hard to hide this information. So to be conservative, we give the adversary access to this information. So that's our anonymity metric and finally we need to understand what estimators are we analyzing? So what power do we give to the adversary? So we looked at two estimators, the first one we call the first-spy estimator, so this is the simple algorithm that I told you about earlier where if I've the eavesdropper, I'm going to point to the first node that sends me the message. So in this case, the smallest time stamp is tao-4, which is .3, so I'm going to guess that that guy is the source of the message. Now, first-spy estimator is very simplistic. Notice that it's not making use of the graph at all. But we decided to use it. Because the security community was still using this estimator so it seemed like a reasonable estimator to look at. The second estimator that we looked at was a maximum likelihood estimator and this is a more powerful one. So this is computing what is the probability of observing the time stamps that I observed, 
    Conditioned on each node being the source? So it's a conditional probability and we're taking the node with the highest likelihood.
    And notice that this makes no assumptions about computational boundedness. So this is allowing for a computationally unbounded adversary, they're given access to the structure, as well.
    So I've defined to you now the structure of our graph, the metric that we're analyzing and the estimators that we looked at. So now we have enough for a well defined problem, so let me show you some results.
    So this plot is showing asymptotic probabilities of inflection. And I want to point out two things about these expressions.
    The first is that for the first time time stamp estimator, as your degree gets higher and higher, your probability of detection goes to 0. Why might that be the case? Well, let's think about it. If I have more and more neighbors, the probability of me sending to one of them first and then they relay to the eavesdropper before I do, gets higher and higher, because my number of connections to the eavesdropper is constant.
    OK? So this makes intuitive sense.
    However, the maximum likelihood estimator has a probability of detection that's actually bounded away from 0, no matter how big the degree is. So this is really showing you the power of knowing the graph structure, if you know the graph, you can do a lot better.
    And the other thing that I want to mention, which is really the point of why we were doing this study in the first place is that asymptotically, the probability of detection for trickle and diffusion look the same. And in fact, even the constants are pretty similar. I'll show you some simulations in a second. So this kind of suggests that the change that was made wasn't really solving the problem.
    And the intuition here seems to be that the symmetry of these two protocols outweighs any local differences in randomness, so what I mean by that is that all of the nodes are sending messages in all directions over the graph at roughly the same speed. So it's like a ripple on a pond. Both of them are growing like ripples and the adversaries job is to pinpoint the center of that ripple. So I'll go quickly over this, because probably most of you don't care but I'm going to very briefly talk about how you would prove the bottom right hand result. So maximum likelihood for diffusion.
    And the idea relies on some random processes so let's assume that these yellow nodes are the nodes that have received my message and let's assume that the blue nodes are the ones that have already reported to eavesdropper, so the eavesdropper only gets to see the blue nodes and what we're going to do is count how many blue nodes are in each subtree neighboring our true source and our our candidate sources.
    OK? And if that number is roughly balanced, we're going to say this is a candidate source.
    OK, so in this picture, we see that each of our three subtrees has 1, 1, and 2 blue nodes, so those numbers are roughly equal. So we're going to say, this is a candidate source, this could have been a real source.
    However, if we move one over, now the numbers are imbalanced. Now, we have 3, 1, and 0, so we say this is imbalanced, this is probably not the source, so we discard that. And what we can show, using Polya urns and other sources, that's how you get this high probability of detection.
    OK, so so we talked about some theoretical results, but they are asymptotic in D, which is the degree of our graph. Now, this doesn't really make sense, or it's kind of a weird result.
    Why?
    Because in practice, your graph isn't changing. You're given a graph, and we want to know how your probability of detection changes as the adversary deploys more and more resource, so makes more and more connections.
    So this plot is showing that in simulation. you can actually get it from the theoretical results, too, it's just hairy.
    Trickle and diffusion have almost identical performance, so this is what I was saying earlier about the constants in the big 0 notation are very close.
    And we also ran estimations which shows that there is a little bit of a separation if you don't run these on tree, but the key point is if you look at the average degree of nodes in the graph, the theoretical results pretty closely match the predictions that we get from our tree analysis. So this is kind of validating after the fact the analysis on trees.
    And I want to point out here one thing, which is that these numbers, these probabilities of detection are super-high. Like, if you look -- this y axis starts at .3, OK? And here the number of eavesdropper connections is really slow. So this is a little bit concerning.
    And it seems to suggest that diffusion doesn't actually have significantly better anonymity properties than trickle.
    So this motivates the next part of my talk, which is on what can we do to fix the problem?
    OK, and I'm going to talk about a system that we've been working on called Dandelion that addresses this particular problem.
    Now, before I talk about Dandelion and the work that we've done on this, there's some very natural first order results that I want to mention that probably popped into most of your heads. So one of these is why don't you just use Tor? And in fact, this is something that a lot of people do in practice, so a lot of people do connect to the Bitcoin network through Tor and precisely because they are worried about network-level attacks on their anonymity.
    So the idea here is that the source would pass their transaction through the Tor network to connect to some random other node in the network, so the blue guy, let's say, and the blue guy starts disseminating the transaction.
    Now, this does work, and Tor is addressing the same problem as we are, but from the perspective of a system designer, you don't want to be designing a financial system that has broken privacy and you're relying on people to like, know about that problem first of all, second of all have the technical know-how of being able to use Tor and set it up with their Bitcoin clients and all of this. So from the perspective of the system designers, they would like to have privacy sources built in, they would like to automatically be taking care of this issue. You might not want to rely on a third party for like critical services.
    So a similar solution is to integrate either something like Tor or I2P into your peer-to-peer network and this is something that has actually been happening at Monero, which is another cryptocurrency.
    They're trying to build I2P routing into their peer-to-peer network, so the I idea would be that you have these tunnels and you would tunnel your transaction to some random node, blue guy once again, and blue guy disseminates your transaction.
    This in principle does solve the problem. But I'm sure a lot of you may have run into: Implementing cryptographic protocols correctly is time consuming and hard. 
    So the project in particular, they've been working on it for a feweer now, and there's a lot of complexity. And this is not to say anything about the competency of Monero software engineers, it's just hard in general. So what we were trying to look at in our work is something that was very simple and lightweight and easy to implement on top of existing solutions, so I will talk more about that work, Dandelion.
    So when we started looking at Dandelion, we wanted to be able to have some kind of theoretical privacy guarantees, so privacy and security are two of those things where you really want guaranties, because otherwise you don't know where your weaknesses are until they pop up later and of course guarantees are only as good as the underlying model so the model that we used for our analysis is a bot net adversarial model. So we assumed that some are corrupt and their identities are unknown to anyone and they're able to observe all of the metadata that comes to them and these spies collude with one another. To begin with we assume that they're honest but curious, but later we did some work to harden this against more robust adversaries.
    Since we're academics, we had to make -- look at harder version of the problem.
    [laughter]
    So but this is the model that we used and the solution that we proposed works also for the eavesdropper model, so OK, the other kind of subtle point that we looked at in this work that is a little bit different from prior work on privacy in peer-to-peer network is our metric.
    OK? So we assumed here that each user is generating some number of transaction, so let's say that number is one. Each user has one transaction. And the adversaries, now, the spies are collecting all of this information, all of the time stamps, and the adversary's job is to collection information about these transaction. Now, given this mapping we evaluate how good it is by computing its precision and recall. So recall is defined as follows: We count the number of correct arrows in our mapping and divide that by the total number of users.
    OK? So in this example, there's only one correct arrow from the red transaction to the red guy on top. So we get a recall of 1/3. Now, notice that in expectation, recall is equivalent to the probability of detection that I analyzed in the first part of the talk, so really I haven't done anything new here. Recall and probability of detection are the same.
    Now, the part where we do differ is precision.
    And precision is computed as follows: For every correct arrow in my mapping, I'm going to count the number of other users that also got mapped to the same node.
    OK, so in this case our red transaction is mapped correctly, but the adversary also mapped two incorrect ones to the red guy. So the red guy gets a value of 1/3, the others have nothing mapped to them, so they get a value of 0 and we average those. So this has a precision of 1/9. So what is this precision capturing? In a sense it's capturing some deniability. So if the adversary maps all of the transactions to one person, the person says, oh, I couldn't have generated this one, because you're saying that I generated all of these different ones and they clearly came from different individuals. So precision is capturing how deniable -- how much deniability.
    So our goal here is to design a distributed flooding protocol that minimizes the maximum precision and recall achievable by any computationally bounded adversary. This is a bit of a mouthful so I'm going to try to interpret this goal in a picture.
    OK. So let's look at a plot of precision and recall.
    So both of these are bounded between 0 and 1. And remember that P is our fraction of spies in the network.
    So the first thing that we showed is no matter what spreading protocol you use and no matter what strategy the adversary uses, your precision and recall are always contained in this almond shape in the middle of the plot, OK? And why is that? That's because you're constraining -- you've constrained the number of transactions in the system, so if precision is high, recall is also going to be high with some slack. So we're always stuck in this central almond. Let's say we fix some spreading protocol. Let's say diffusion. Now, the adversary could try every possible estimator for trying to guess the source of my transaction. And as the adversary guesses different estimators, each estimator has a different point on this plot, OK? So if we trace out the set of all of those points, we get a region. So this purple outline is outlining one of those regions. OK?
    Now, what we can show is that no matter who the adversary -- what spreading protocol you use, the adversary is always get a maximum recall that is at least p, to so to the right of the vertical dotted line and a precision that's at least p squared, so above the horizontal dotted line. So recall is a little bit easier to understand. The intuition is that -- like I have some neighbors and I'm sending my message out, with probability p, the first node I send to is going to be an adversary, because I have fraction p nodes in the network.
    So if the adversary just does this first spy estimator that we talked about earlier, they'll be right with probability at least p, so that's why your maximum recall is always at least p.
    So we have these fundamental lower bounds, we can't go beneath them, and they imply that the best we can possibly do is to design a spreading protocol that has a region that looks like this little green triangle. that's the best we can hope for. If you department follow that, that's fine. The thing that we want to take from this is we want to be in this green triangle. We'll come back to this later.
    
    [laughter]
    So how can we hope to achieve the green triangle? Well, there's two properties that we want in a spreading protocol. The first one is asymmetry. So remember we said earlier that trickle and diffusion are the same in the sense that they spread at roughly the same rate. So they have some symmetry to them. So we want to break that symmetry in order to have better anonymity. The second property we want to look at is mixing, and here I mean something completely different from mix networks, so let's suppose we have a line of notes and a spy at the end, and each of them are passing their transactions towards the spy. So the spy gets to see four transactions, but because they all came from the same path, there's no information that allows them to distinguish which one came from which node, OK? So we want to make it so that the metadata from different nodes looks roughly the same to the spy, it gets mixed together. And we can do that by controlling three knobs. The first one is the spreading protocol that we use. So like right now we're using diffusion, but in principle we don't have to use diffusion. We could use something else.
    The second one is our graph topology, so right now, as I mentioned earlier, Bitcoin and a lot of other cryptocurrencies are using randomized regular graphs, so each node is choosing some number of neighbors randomly.
    And finally, the Dynamicity, so how often is the graph changing.
    Typically we think of ...
    OK, so we have these three knobs and we're going to propose a protocol that changes all three of them. So the first knob was the spreading protocol. So our protocol is very simple. Let's suppose that we start at the left-most point. That's the true source. Instead of sending the message to all of your neighbors, you're going to send it to exactly one, OK? Then that one neighbor is going to flip a coin and if lands heads, they'll forward it to one of their neighbors and if this continues for a random number of hops until somebody flips tails and when somebody flips tails, then they'll start diffusing the rest of the message across the rest of the graph. So we have this anonymity phase which is the first part and the spreading phase which is the second part.
    We call this Dandelion because it looks kind of like a dandelion seed head. So why is this a reasonable thing to do? You can show that this Dandelion has an optimally low maximum recall of p + 0 of 1/n terms. So remember we had this fundamental lower bound that said no matter what you do, the adversary will always get a maximum recall of at least p, OK, so this is as low as we can push our maximum recall, and this is nice, because now it means we can just focus on precision, we don't need to optimize two metrics anymore. Remember we had precision and protocol but now we can just think about what graph topologies are going to maximize our precision. The second knob was graph topology, and so for Dandelion, we look for a line topology that looks like this. In addition to that, we're going to have an anonymity graph, which is the thicker black lines around the perimeter. Now, whenever a transaction comes in, it's going to propagate clockwise over the anonymity graph until someone flips, what was it heads or tails? , I forget. Tails. You thank you and then they start diffusing over their regular graph, OK?
    Similarly if a second transaction comes in, they're going to propagate clockwise over the same anonymity graph, the same line that's important, and then start propagating.
    OK? And this graph topology, this is actually one of the key differences between Dandelion and prior anonymous communication protocols in peer-to-peer networks, because oftentimes similar protocols will often just choose like a random path through the graph and that actually gives you worse privacy guarantees than if you keep this same line topology that I just mentioned. OK?
    And then our third knob was dynamicity, so we're going to  change this anonymity graph frequently which can be done by having each node choose their next edge in the cycle or reset that next edge in the cycle periodically.
    So to summarize, the Dandelion network policy has three parts: Part one is the spreading protocol. So we're using dandelion spreading here. Part 2 is the graph topology, so we have a line graph. And part three is the dnamicity, and of course all of these things are made precise in the paper, but you can show that under these conditions, Dandelion has a nearly optimal maximum precision that looks like log p, sorry p squared, log p, so sorry, so remember our fundamental lower bound on precision was p squared, so we're a logarithmic factor away from that, OK in so if we go back to this picture that we saw earlier, remember we wanted to be in the green triangle, so Dandelion is a logarithmic factor above the green triangle on the precision side and it's meeting the green triangle on the recall side. And if you compare that with diffusion, it's giving you substantial privacy benefits.
    OK, so I've explained to you what the protocol is, and what guarantees it gives. But I would like to give you a little bit of intuition as to why this is maybe a good idea, and to give you that intuition, I want to tell you about some things we tried that didn't work, OK?
    So in particular, some graph topologies that don't work. So the first thing that we thought about was a tree graph. So let's suppose you have like a binary tree, so you structure your peer-to-peer graph like a tree. Let's suppose we have this tree and everyone's passing their messages up to the root of the tree, OK? This turns out to have a precision that scales like 0 of p, remember, we wanted it to be p squared. This has inadequate precision. Each one of this nodes can automatically deanonymize everyone behind it. So basically having a lot of leaves is a problem, and in trees like this one, leaves are going to be like half of your graph, or even more, OK?
    So the intuition here is that a tree graph has too many leaves, so it gives you poor precision guarantees.
    Another very natural graph topology that people often talk about in the context of these types of problems is a complete graph. So everyone is connected to everyone.
    And here again, OK, it might not be obvious from this expression, but here again you get a precision that is suboptimal, OK? Now, why is that happening?
    Well, it's happening because there's basically too many paths in a complete graph.
    So remember earlier we talked about this mixing property that we want. We want different transactions to take the same path on the graph.
    But in a complete graph, you have so many different paths inside that the probability of any two transactions taking the same path is actually very small.
    And this is why you don't get good precision on a complete graph, OK? So I want to wrap up with a quick discussion on the practicality of Dandelion. So we did implement Dandelion in a Bitcoin client and tested it out on the real Bitcoin network to try to understand how much overhead it incurs, so how much latency in particularly. Because since you're adding this original anonymity phase, you're adding a little bit of latency in terms of how long it takes to reach the transaction in the rest of the network. And that latency scales with the length of your path. So the longer the path is the longer it's going to take to reach everyone else. So we found that if you keep your path lengths to about 10 nodes you're adding about 2 seconds of latency, which probably sounds terrible to those of you who are working on high-speed application, but actually if you look at the propagation speeds in a lot of these cryptocurrency networks they're on the order of seconds. So like the average -- I think it was in 2013 was around 10 seconds.
    So adding a couple seconds to transaction latency is not the worst thing in the world, and also blocks are anyway only generated once every 10 minutes, so: These kinds of latencies could be problematic in certain applications but in a lot of cryptocurrencies they have to have slowed-down block production because of security constraints, so this was not an issue for a lot of cryptocurrencies.
    So I will -- I'm just going to wrap up with this slide that I thought was kind of cool, came out of Princeton in 2017, and this is showing you on the horizontal axis, the date of invention of various technologies that have been invented for cryptocurrencies and on the vertical axis we have the strength of guarantees. The cryptographic unare the strongest, -- used in some alt coins, so other cryptocurrencies, that's the blue one, and the gray ones are just not adopted at all. So Dandelion, our approach here was to try to max out the guarantees that you can get from obfuscation-based approaches and try to get some theoretical guarantees on that without transitioning into occurrence. So far Dandelion has not yet been implemented in Bitcoin core, but it's a Bitcoin improvement proposal so we're talking to some of the core devs. But it has been implemented in a couple of cryptocurrencies including Grin and Beam, this is the right crowd. Has anyone used Bitmessage? It's an anonymous peer messaging system. I think it has like 100 users,
    [laughter]
    But I was still excited. So take-home messages. Bitcoin's peer-to-peer has poor anonymity. And this is not a Bitcoin core thing. Second issue is that moving from trickle to diffusion didn't help. So statistically they have very similar anonymity performance and third lesson is that Dandelion may be a lightweight solution for certain classes of adversaries, so this is a link to our Bitcoin improvement proposal, thank you all for your attention.
    [applause]
    
    
    ZEESHAN:  We can take a question or two.
    
     AUDIENCE:  The -- how does this relate to distributed file systems, where you're trying to, rather than broadcast a transaction to an entire network, you're trying to enter a, like, key value pair essentially into a global registry, because those systems typically work on the basis of mapping that files back to like the nearest IP by some hash function, so you don't have the same ability to go hide, if you will, the source point of the message, you're still trying to map it back to a single physical computer.
    >> OK, good question. I haven't thought about that space -- I don't know very much about that space, so it would be great to talk to you a little bit later if we could. I'm not sure what the spreading protocols actually look like in those systems, so that would impact the answer.
    ZEESHAN:  We'll take one more.
    >>
     AUDIENCE:  Is there anything could could be done to keep the bad actors out of the node network in the first place? Like, you know, it mean it seems like an obvious step to say that you've got to be qualified to be on this node network and therefore you can't have eavesdroppers on it. Has that been researched.
    >> A lot that are coming out today are permission, and these tend to be less problematic than these permissionless block chains. It is hard to figure out who is and is not allowed, in part because privacy attacks are very difficult to detect. However, there are companies, like there's a company called chain alysis who is entire business model is to analyze Bitcoin transactions and give you analytics, so basically trying to deanonymize people, so it's difficult, I think, to do a reasonable job at filtering out misbehaving nodes, especially if they're running privacy attacks.
    ZEESHAN:  Thank you, Giulia, you're here today for another few hours, so ...
    [applause]
    
    
    ZEESHAN:  You can find her over lunch. And we have lunch. Lunch exists in food trucks, make sure you have tickets. If you don't have tickets, you can get them out front at the registration desks and the trucks will be, you go up the stairs to the main hall, outside there will be a. The taco truck only has tacos, you can always get sodas and coffees here. So if you have questions, you can talk to us, as organizers, and make sure you get your lunch. 
