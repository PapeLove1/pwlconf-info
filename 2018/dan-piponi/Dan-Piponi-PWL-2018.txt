    Stable Fluids
    by Dan Piponi
    
    >> All right, hitting that final talk!   Everybody take their seats.: All right, so Dan Piponi is an awesome cat who I only knew initially from his blogposts about functional programming, and yeah, we're here next to ICFP and I was thinking, Dan, he'll probably want to do some crazy talk about maybe something in category theory or something about functional programming. I learn about: But then we were talking and Dan has an amazing background in graphics, you know, he worked on a thing called the matrix trilogy, pretty cool and he sent me this email when he picked this paper, the stable fluids paper. That especially wanted to talk about. He said many years ago he was chatting with someone and he said this person would love to see a presentation on how fluence ... Dan was like, everything you need to get started is it contained in this 20-year-old paper called stable fluids and it was a big inspiration for a lot of this stuff and I was like, one paper can talk about all of that, and I was like, we have to do this for a Papers We Love talk, right? So yeah, thank you Dan for being here and without further ado, Dan Piponi, everybody.
    [applause]
    OK, stable fluids by Jos STam H. M so it was about stable fluids for music videos, that sort of thing. Why would you want to do this? A quick anecdote about this. About 20 years ago when I was still working in the visual effects business I went down to LS. Well, down, it's probably up from here, but anyway to work on a little bit on a movie called Deep Blue Sea which probably none of you have seen. I'd never been in a pyro shoot before. They have the cameras running and they explode things on video and we look at the video with the frame with the helicopter, which is beautiful, and the next thing, where there's nothing left. They'd completely blown tup because they'd packed too much explosive in so the crew actually have to go around and collect all the pieces on the floor. If you look YouTube, you can find this clip listed as best movie explosion, so it did work in the end. But you can see there's a lack of control and it's expensive. So computers can do this stuff cheaply. So I thought we'd look and see what the earliest example of fluid dynamics in a movie is. Computational fluid dynamics and it turns out to be 2010, made in 1984, where they used computational fluid dynamics to simulate the atmosphere of Jupiter. This used the most powerful computer at the time that you could use. And it stretched it to the limits. They had to figure out the streaming trick to work their way through all of the data. 1999, this paper was published. So this is actually quite a convenient thing. There was a tweet in my stream just a couple of months ago, where someone says, um, let's see, what were the exact words? Arguably the most influential paper in PDEs for graphics, that's partial differential equation, makes CFP accessible to almost anyone. So with an endorsement like that how could I not talk about this paper which I already loved? There's another aspect to this. So there was one reply. Computational fluid-like dynamics, this is a little bit snarky, but I'll talk about that, as well.
    
    [laughter]
    
    It's not science, OK. So what do I mean by influential. I could tell you about the thousands of citations this paper has, but you go to YouTube and type in stable fluids and you get this endless stream of fluid videos and these around people that bought some off the shelf package. These are people who've read the paper. So this contradicts frank Pfenning's taught talks earlier. I think people actually read this paper. These are people who have sat down and coded fluid dynamics for themselves. I mean this paper enables people to do this. Hundreds of people have done this and posted on YouTube and I am I'm sure thousands more haven't posted on YouTube.
    So this paper took us from, well, so in 1984, we had this thing running on a Cray, but in 1999, there was actually a little bit of resistance from the committee where this was presented. I think they wanted a harder paper to feel like there was some real substance in there and even after the paper was published, people were still skeptical because it had been demonstrated on a high end sort of graphics machine and they said well, you can do anything with enough power. So a couple of years later, Jos gave us a live demo on one of these things. I have to explain about this. It looks like a phone so you think it's super-powerful. This was a pocket computer. I couldn't find any use for it, it was so underpowered. Forget GPUs, forget about multi-core, this is just a single-core CPU with no floating point unit, OK? But he got a real-time demo. With his finger, well, actually it wasn't his finger, it was a stylus, there weren't touchscreens then.
    At that point, I think people realized in retrospect that this was a good paper.
    
    [laughter]
    
    In fact, I tried to dig out a demo from the period, so this is actually Bill Buxton, who was chief scientist at a couple of companies including Silicon Graphics, so there were touchscreens, they were kind of rare, but that's the kind of simulation that people got really excited about in 1999.
    So OK, time to start doing some fluid dynamics, first we've got to make a decision, OK? There's two approaches. There's others, slightly off the wall approaches, but there is basically two approaches, one called the Eulerian approach and one called the Lagrangian, there's two ... This there's actually a complete explanation of what I want, so I might as well just read that.
    [laughter]
    
    So it says, due to the nature of music, it can be said that there are two ways of perceiving it, the Lagrangian specification, the listener may allow themselves to be carried along with the music as a leaf might be carried along on a stream of water. On the other hand, in the Eulerian specification, it's also possible to perceived it as a flowing rock might perceive a stream allowing the water to move around it in a continuously changing flow. This is actually exactly right and I'll show you what that means. So at the end of a day, a fluid dynamics demonstration is about a vector field of velocities, that's the field that you care about. So what kind of data structure are you going to use to represent that? Well, you could just store them on a grid. I wasn't sure if the vectors were going to come out on this screen, but so you could just throw them on a regular grid. The vectors don't move, but the vectors themselves change over time. Nice easy data structure to work with. Does mess up the mathematics a little bit, and I'll talk about that. And the alternative approach is the Lagrangian approach, where you actually track particles, these are the leaves floating with the water, so you store the velocities just in the particles and don't store anything in between. And nice from the of dynamics, but the problem is from a data structure perspective, this isn't very nice. The structure keeps changing all the time. Some particles come on, some particles disappear, you can do all that, but we want easy, so we'll go with the Eulerian approach. And now comes some vector calculus. Sorry!
    So we're going to talk about div and grad and bet you thought I was going to say directional curl. But no. This is a piece Hawaii, big island, very nice this area. Colors show altitude. The vector gradient is basically an arrow pointing upwards and the longer the vector, the steeper it is. So that's what the gradient of an altitude is at any particular point, it's just that vector. And formally, it's a vector made of a derivatives of a quantity. Fphi. And it works in 2D, as well, for gradient it's these two derivatives.
    We're going to also need, by the way, some of this mathematics, there's some pain you have to go through but some of it is going to disappear away when we get to the actual algorithm, but I think you have to go through the pain to get there and there's a directional derivative. So we use the funny upside down triangle, del, so a del V, if you're driving along in Hawaii and velocity is V. So if you're perpendicular to the gradient, the top product is 0 and that means you're following the contours and you're not actually changing altitude, that's why you get 0 and so on. OK?
    And there's also a thing called the total derivative. This is really, I mean imagine you're driving in Hawaii now, and the weather is changing but not the temperature. The intrinsic change of temperature at a particular place, but also, it's changing because you're driving along and you might be driving from the beach where it's warm up to the mountain where it's cold, so the total change of temperature in your vehicle is going to be the sum of these two terms, the directional derivative and the partial derivative. Actually mentally I call this thing big-D, but I looked on Wikipedia and it seems to have quite a few different names. I can see why some people may get confused about this subject. In fact there was more. I didn't do them all. So you can see why I called them big-D. The last thing, divergence. It basically measures how much stuff is flowing out of any point. So we can draw a little rectangle in a vector field like this, and probably hard to see, but the vectors on the left look like they're a bit bigger than the vectors on the right, so there's a kind of a net outflow on the left and this is said to have a positive divergence. In this case the vectors on the right are bigger than the vectors on the right, so there's a net outflow on the right. The horizontal outflow is basically just the derivative in the horizontal direction and similarly outflow coming from vertical motion is the derivative the other way, so basically the total divergence is just the sum of these two derivatives, and that gives you the net flow. So some textbooks we use different notation, I tried to use word the words grad and div. OK you know what forget my slide. I've got my hand, I can do a demonstration, OK? Show my hand is embedded in the atmosphere and the atmosphere has a pressure. My hand doesn't go to the left because there's also pressure on this side and there's a force which is that area times pressure, OK?
    But if there was more pressure on this side than that side, my hand would actually move unless I resisted it. And again, if you think about my hand in the limit as my hand becomes infinitesimally smaller. intuitively you probably already know that. OK, so now we actually have to do some equations of motion, and get the Navier-Stokes equations, the famous equations. So imagine this little square of liquid. This works in 3D, b I'm doing 2D, because 3D is harder. So ... You have to try and look past the rho and L squared, it's a little bit of fluff but I have to put them there to get it correct. And imagine this moves in the reaction of some kind of force. We want to understand the force, so we use the good old F = ma.
    So that's the force. I've scaled by L squared that I want you to ignore. And then A acceleration, it's the rate of change of velocity of this parcel that's moving. So we need the total derivative. So that's what that DV by Dt is. So at the end of the day, we're saying the total derivative of the velocity is minus the gradient of the pressure. And that's pretty much the Navier-Stokes equation. There's a bit missing but I've expanded out that title derivatively as I've said it's the sum of two terms, this directional derivative and the partial derivative. So now we've got a step towards an algorithm here, we can rearrange this a little bit. We've got a derivative with respect to time on the left and some stuff on the right and when whenever you have a derivative with respect to time like this, you can do a simulation by basically saying the value of delta t in the future is whatever the current is, plus the delta t times the rate of change. It's just the standard thing that we use all the time.
    OK, but there are some things missing here. I've not said anything about how to calculate this pressure.
    And OK, to get the coolest looking simulations you want incompressible flow, so if you have some water and you actually put it in a container and try and compress it, it's pretty hard. Water is almost incompressible, at least at normal forces that we experience in our day. And actually to a good approximation, so is the air, as well.
    Even know you can only hear me because of compression waves, you can still model the air quite well, at least for movie purposes as an incompressible fluid. So we want to include that. So what do I mean by incompressible? Well, it's just this, so basically what we're saying is if you have a region of fluid, there is a no net change of size of that fluid. So everywhere there's no net inflow or outflow. So if you have some water in a container and you squeeze it this way, it's going to expand out the other way, so the amount of flow going in is canceled by the amount going out. So what's what this is all about. OK, the divergence of the velocity has to be 0. So I still haven't answered what the pressure is going to be, and it's kind of a strange answer, really, it's the pressure has to be whatever it needs to be to make sure that the fluid remains incompressible.
    So basically you just have to solve these equations and they're simultaneous equations and that's the Navier-Stokes equations, if you actually know how to solve these analytically. In fact, if you can just prove the solution there's a million-dollar prize waiting for you. I mean these are tough. We can do it generically. We can cheat our way through it and it turns into something remarkably straightforward. I just snipped out a piece from JosStem's paper. It has a label about viscosity which I'm going to skip over and talk about it later.
    Most of the stuff I'm doing hearings I don't need to carry around the force.
    So now I need to talk about a thing called advection, so one of the terms in that in the Navier-Stokes equation was looked a bit like this. It's basically the rate of change of velocity is some stuff plus this directional derivative of the velocity. OK? So this is if you remember the directional derivative is basically how something changes as you move along the path and essential what this is saying is that this is the equation something would have if that quantity is being dragged along the vector field. So this process of moving the quantity along the field is called advection. So that's kind of intuitive picture of what this equation is trying to say. So whenever you see this, you've got to think in terms of driving along the vector field. So let's say we just wanted to solve this equation that just does the advection process, forget to getting to incompressibility and all that stuff. One way you might try to do this is we've got a rate of change thing, I've talked about that already. You basically take the current value and add delta t times something, and you say what's the something? We've got some expression of approximate derivatives from a grid just by taking neighboring values, taking the difference, and dividing by the difference between them. It's the standard method we use to get approximate gradients and this is how you would compute the gradient of a hill if somebody said, hey, what's the gradient of a hill. So we could do that, and then what you'd end up with is a calculation that this calculation, this something would be some combination of things in the near neighbors. So I'm not going to go through all the details, but I have to talk about what would happen if you did that. Because there's a color flow of information now in your code. The data that's here is getting used over there, but no data from further out is being used to do this calculation. So now we can say something about how fast the data moves in this code. It moves in some abstract sense, right? In some time period, delta t, the data moves no further than delta x which is the spacing between the grids, OK?
    Well, maybe a root 2 times that if the data can move diagonally. Well, this is a problem, because if the fluid wants to move faster than that, well, if the information about where the fluid is, can't move as fast as the fluid is meant to work, your simulation is not going to work. What happens is fluid starts piling up where it shouldn't because it couldn't move far enough and you're going to get unstable oscillations coming in, so you basically I have a speed limit. It's a European and American notation for people. So one way to fix this is to make the time step really small so effectively everything moves really slowly through the simulation, but that is really expensive. You don't want a slow simulation, you want a fast stimulation.
    So this is why we have the name of Stem's paper, stable fluids. Well, we made this choice between Eulerian and Lagrangian, but here's our grid. It could be the velocity, but I'm going to think abstractly any quantity on a grid. What we can actually do is we can imagine each of these grid points is actually a particle, just for a short while and simulate the motion of a particle. That's actually not too hard a thing to do, because you have the velocity stored in a grid and you could just take the position of each of these particles and just as the velocity vector and that gives you a new position and you could take that as the motion. Or you could do something a bit more detailed where you take multiple small-point steps and then you'll get a curved path. So if I do that, you could simulate these particles moving. You're going to get something a bit like this. And I've homed in on one of these. Advection wants to basically transport this from this property from one end to the other, OK? So you've got a value on a grid, you could transport it to the other end and then put that number back in the grid. But there are a few catches here in that it didn't land exactly on the grid point. There's loads of ways to deal with that, but none of them are actually all that pleasant and if multiple particles arrive in the same place, what are you going to do? And if you're doing it in a GPU and you have to write data at the same point it could be a headache, but there's a really simple trick. Instead of asking the question, where does the fluid at this point here end up, you could ask at time delta t in the past, what fluid would arrive where I am now? So basically you just flip the vectors and run it backwards and instead of delivering, if there's some kind of delivering going forwards, you actually collect from the beginning of the path and drag that to the current point now and you can collect from the past easily because you can just do interpolation, even if you didn't land exactly on a grid point. So that was his trick. A funny thing is this is not his trick at all, this goes back to the 60s, at least to the algorithms, and in fact the method goes back to the 19th Century actually. It's basically a method called the method of characteristics. But can you cheat, what you do is not update the velocity itself. You can use this process and drag the velocity quite a long way along one of these paths. You can go way beyond the speed limit for the current condition. In fact you can go so far beyond, that the simulation is inaccurate. But it doesn't matter. You still end up with something that looks kind of like a fluid flow. And what's more, it's stable because you're always just interpolating, which is kind of a weighted average of the neighbors. So it never explodes and goes out of control, which can happen with the other kind. So whatever you do, this is a stable simulation. It might not be scientifically accurate, but it's going to be well behaved, and so this was the key thing that allowed me to run simulations much faster than other people were doing. So I thought I would give an idea of how some of these flows. Some people use Mathematica and other places, I like to use Shadertoy. A shader is basically just a piece of code that's given the coordinates of a pixel and you return the color of that pixel but the cool thing is it runs on a GPU, so actually the fastest, easiest way to get into fluid programming. So I need to make up some incompressible flows, so make, I can use a bit of geometry here. Pick a random pair of vectors, A and K, whose dot product is 0 and then make this function. So basically that's some kind of wave of velocity, you can imagine the crests of a wave like this, but the amplitude of these waves is perpendicular, so if the direction of motion is this way, so you have the wave crest like this, the motion is actually perpendicular, so this is actually a kind of a wave motion like this. So you can see how it's incompressible because there's only sheering motion going on, OK? In fact, you can prove it if a div of this is 0 with a bit of calculus.
    So actually, you can do something else, you could take lots of terms like this and add them all up and that's still going to be an incompressible flow. So I write a bit of code in Shadertoy. And I'm going to use a method to drag this checkerboard, and it flows something like this. So this is an incompressible flow. Each of those squares may get distorted but they're staying the same size. And you can see there's a lot of fluid stuff going on. It's got these vortices going on. All vortices are staying in the same size. We could try the opposite, as well. We can try -- I can make the amplitudes parallel to the direction. So this would be like a wave with a crest like this, and the velocities are like this and you can see how this is basically compression and rerefraction, so this is the opposite of what we want. So a field like that would look like that.
    And then if you run that, so what happens is you get these flows, you can see there are points that are kind of sources and there are forces and forces that are sinks.
    And you can explain this a little bit better, actually, see that function where the amplitude is equal to the direction, that's the gradient of another function. Fee, which is the sign thing. You can think of this as peaks and valleys, where the bright whites are the peaks, the dark parts are the valleys, and the flow well, it's going backwards here, but it's going from the valleys up to the peaks, so the peaks are the sinks and the valleys are the sources, but the appropriate thing is these are the gradients of something. We can do this for any kind of wave. So if you've got any wave, any vector times a cosine, you can split the amplitude thing in the front between perpendicular and parallel parts, and you get one of these compressible flows and you get an incompressible flow, but if you remember Fourier taught us that any function can be written as a sum with a bunch of sine waves like this. So any function, you can write it as a bunch of sine waves, and split them up into a compressible part and an incompressible part and then reassemble them.
    We and we can call this P for production. You then perform this projection operation and then do an inverse for your transform. So this is just a snippet from the paper showing this projection operation, and the thing on the right, on the second line, is basically some geometric algebra stuff, well, some dot products to compute the projection. So we're almost in a position now to start solving as I put these pieces together. This is part of the Navier-Stokes equation, OK, the velocity, rate of change is given by this directional derivative, minus the pressure force.
    So this is a derivation in Stem's paper, but it is standard stuff. You can apply this P operator to both sides. On the right, well, one term is a gradient, and I've already pointed out that gradients give rise to these compressible flows and that's what this P operation is designed to remove.
    So actually, that's what the equation simplifies to. This is now pretty much an algorithm. What this says is that we can take a velocity field on a grid, we can interpret this thing as saying, for some time, delta t, we can drag our velocities along, using that dragging method and then we can do this projection here. So what's happening here is you have an incompressible flow to start with but when you do this dragging operation, the advection operation, it might not be incompressible anymore, so we fix it applying this projection and that's pretty much the complete algorithm right there, actually.
    So this is how it's described in the paper. We did it with two steps. I've colored them to see where they correspond to in the equation. Diffusion again is about viscosity. I'm ignoring that for the moment and you can also add in whatever forces you like and apply the projection step to make sure that the result is still incompressible.
    So here are some pictures from the actual paper. I'm not going to show actual video because you can go on YouTube and find countless videos that I've showed you. But these are some images from the paper and I can't tell you how excited we all were in 1999 to see this. So now move forward I'll talk about some stuff that I worked on, quite a few years ago now, but very much inspired by some of these methods, but what I've described isn't enough to do like production-scale fluid dynamics for movies, so here's one thing that's missing.
    So here's some fluid with some kinds of things had you expect to see in fluid, I guess.
    [laughter]
    
    So these things provide boundaries, OK? The fluid around here, we want it to match the velocity of the thing that's in there. But what I've described so far doesn't know anything about objects being in the scene, doesn't know anything about matching boundaries, so we somehow have to solve the previous problem, the Navier-Stokes equation and somehow match boundaries, as well, and if these things are actually moving, you want to match the velocity vector and if it's spinning, you want to match those vectors, too.
    So we have two problems to solve here. We can do it with a Venn diagram, right? I told you about all of these incompressible flows, you could also mention there's a set of flows that have the correct boundary, that includes all kinds of crazy flows, vectors pointing in all direction, as long as they have the correct thing along the boundary and we want to find something that's in the intersection, and this is actually potentially a very difficult problem to solve but there was a nice paper that has a beautifully simple solution to this. First let me make it more realistic, the intersection is actually really small. In fact, it might be one point, OK? And this method, OK, well, I'll tell you about the method generally afterwards. So there's a point that represents the current state that's neither of these things and we want to move it towards the intersection. OK, well. We know how to project onto the space of incompressible flows, that was the Fourier thing that I talked about earlier. And we apply that there. There's a really easy way to do this, and this sounds ridiculous that there is a thing to do, all uh want to do is put a in some sense that's the closest velocity field to the one you started with that has the correct boundary conditions, so you can just do that and amazinglying you can keep doing this and eventually it finds its way to the point in the middle and it is great, because you didn't have to understand any of that. You could just do this. It's so simple. I couldn't believe T I mean even though these are like billion-dimensional vectors, literally, right? If you're doing a fluid sim with thousands of cells in each direction, there's billions. This was like three or four iterations and well, good enough, so that's great.
    
    [laughter]
    
    So I got that from this paper. They call it iterated orthogonal projection, I'm not sure they realized that this was actually part of a more general scheme. Alternating projections is used all over the place, electron microscopy. all kinds of mathematical problems. I mean not exactly in this form, but that's a kernel of something, so I love that algorithm and I would have talked about it if I could find a decent paper on it, but ...
    So I should mention viscosity. Bunch of molecules in a liquid moving around bouncing all over the place. When two of them collide if they have wildly different velocities, the chances are after they're going to have more similar velocities. Well, actually their velocities are going to be similar. Typically what happens in a collision, they kind of share out the total energy of them, right? So this happens with fluid. When these molecules interact, they tend to sort of cancel each other out and smooth out the differences and so what viscosity does is if you have a vortex like this, over time it does spread out but it just fades away. And you lose velocities, so you don't want viscosity. I think the history of animation of fluids is pretty much a war against viscosity, and one of the reasons for this is that I mentioned that you interpolate fluid at various points from the grid, well, interpolations are just weighted averages of quantities and every time you average you're basically doing a smearing-out process just like the colliding molecules, so you don't want to interpolate, but the method requires you to interpolate, so you're introducing numerical viscosity it's called. There are ways to work around that. If you work at high enough resolution, as well, you'll find the vortices do last for a long time.
    This is a picture from the paper. It's easier just to describe it. You can do the inadvection step that I described, and you're going to think there is probably going to be some error in there, you're not going to get to where you started from because there are errors in interpolation, so you come back not quite to where you started from, but you can look at the difference from where you start and end and that tells you how much error was accumulated so if you guess that maybe half the error accumulated on the way out, you can just add that half difference onto the end, so that gives you a correcting to some extent and this makes your vortices last a bit longer. And that's actually from this paper. Again, unconditionally stable. This is the big thing. It's more important to be stable for these kinds of things than to be accurate.
    [laughter]
    
    Almost everything I've described here we used in a GPU server called Plume when I worked at Industrial Light and Magic. We did try to use Fourier transform based method but at the time we actually had to use another method called multigrid. It capital deal with boundaries, so way we used a trick I just described for dealing with those boundaries. I'll show you some of the results we found. I can't take any credit. The artists I work with, I cannot believe they produce images that look so good. So these are just some clips from YouTube that I know definitely used the tools that I worked on it's a slow motion but all of the dynamics of anything fluid, fire, smoke, dust, explosion, this is all come from one of these Silvas. In facts there's multiple simulations going on and then they're all composed together by the compositor. And all the interactions from the building and the fluid that's all comings coming from this projection algorithm. The resolution is not quite as high as I like, but it definitely works on an industrial scale. It probably still takes -- I mean to do one of these 3D simulations probably takes about an hour, running on a GPU, at least it did ten years ago. Today it's probably a little bit faster but these with way bigger simulations than was originally done in 1984, so -- and we can also use it for things like just simulating air and making these droplets of water. It doesn't look that great from here at all, actually, but anyway. So there's a whole bunch of vortices and things that are forming and you may recognize this from Star Trek. So I was pretty excited that they used my stuff on the Enterprise. So I stopped working for industry light and magic and I went to work for Google X. Project Loon you've probably heard about. It's made to provide data from all over the world from balloons. It's a pretty crazy project. But that was the goal of crazy projects at Google X. So one of the challenges here -- I mean my colleagues were all having fun task Android phones to balloons and all of this stuff. But somebody had to actually do some theory and I was one of the people that started the theory. One of the problems is if you have a balloon A and you wanted to get it to B and the only thing you can do is change the altitude, what's the optimal choice of altitude that you can make. So again, Lagrangian or Eulerian? Actually want you want is to be able to give an instruction to any balloon at any moment in time wherever it is in the world telling it whether it should go up or down. So you want to build a map of the entire world saying up or down as a function of where you are and what the time is. And if you make a map it's going to be a grid, so you actually want to use an Eulerian approach, and it ends up planning a thing called the Hamilton-Jacobi-Bell equation. It was written for a completely job previously. But it worked out well. So I don't know how I'm doing for time, but I should fast forward and mention some of the techniques people are using today. So this is one possible lar approach. Instead of instantiating particles on a grid and then killing them, you could have a bunch of particles and keep them going the entire time. So what you do is transfer the velocities from the particles to the grid, then do that projection thing and then transfer back to the particles, so that's called the PIC method. But if you notice it's got these little transfer velocities to the grid. There's a trick you can do, you can bring the changes from the grid back to the particles or you can blend them in various ways or whatever, and this is actually I think maybe the primary method that works these days. It works really well, produces fantastic quality results. that's in this book. And finally I mentioned the future. So I wonder if you can guess what's going to come up when I hit the space bar, because of course it has to be a neural network, right? I haven't looked into this very closely, I've basically just read this paper, but basically I you can put in the input parameters from your simulation and do loads of simulations and train your neural network to recognize it. But there's something else that's quite interesting here. Generally there's a thing called a variational encoder, using neural networks, basically you can take a fluid sim and you can find a reduced representation, a smaller number of numbers to describe it. In fact the neural network can basically figure this representation out for itself and give you functions to convert from this latent space, it's called, which is reduced, to the original space. You can go back and forth.
    And so it's like a kind of magic where the neural network figures out a simplified way of doing fluid dynamics, and also if you tweak fluid dynamic sim in some random way chances are it's no longer a valid simulation. So I don't know, that's speculative, but interesting times ahead, and I just want to finally just credit a couple of people, Jos Stam, obviously, and my colleagues, Olivia and Ian who wrote Plume with me. So that's it.
    [applause]
    
    >> Thank you, Dan, that was great. So actually a big round of applause for all the speakers today.
    [applause]
    
    Amazing. And not all, but a lot of our speakers are around the. They're around for Strange Loop, you can talk ta them, they would love that. There are food trucks outside with food. At the hotel. All right, good, thank you. At the hotel. The Union Station hotel for those not staying there. 1820 Market Street. There's food trucks and then there's the City Museum party tonight, which everybody at Papers We Love, even if you don't have a Strange Loop ticket u' invited to go. It's a pretty crazy awesome museum and that starts around 7:00. There will be shuttles from a lot of the main hotels. Otherwise, that's a wrap for the PWL Conf, thank you speakers, thank you volunteers, thank you, you.
    >> If you are interested in setting up a papers we love chapter near you you can come talk to any of us in the shirts can give you instructions on that, and guide you to your first meetup.
    >> And we have a lot more notebooks downstairs at the registration desk, take them, take them for your friends, get the word out.
    >> We don't want to take them home. We all live in very different places ... ... 
